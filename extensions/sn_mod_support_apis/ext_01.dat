<?xml version="1.0" encoding="utf-8" ?>
<mdscript name="Chat_Window_API" 
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" >

  <!-- @doc-title MD Chat Window API -->

  <!-- @doc-overview
  MD API support for working with the chat window.
  Can be used to listen to player entered chat text, set up custom commands
  and callback cues, and print new text.
  
  In addition to what is described below for the cues, there is some
  additional functionality regarding the standard egosoft commands:
  
  * `/rmd`, `/rai`, `/rui` may be used in place of 
    `/refreshmd`, `/refreshai`, `/reloadui`.
  * When a refresh event occurs, scripts may detect this using the conditions:
    - `<event_ui_triggered screen="'Chat_Window_API'" control="'refreshmd'"/>`
    - `<event_ui_triggered screen="'Chat_Window_API'" control="'refreshai'"/>`
  -->
  
    
  <cues>

    <!-- Register the main lua file. -->
    <cue name="Load_Lua_Files" instantiate="true">
      <conditions>
        <event_ui_triggered screen="'Lua_Loader'" control="'Ready'" />
      </conditions>
      <actions>
        <raise_lua_event name="'Lua_Loader.Load'"
                         param="'extensions.sn_mod_support_apis.lua_chat_window_interface'"/>
      </actions>
    </cue>
    
    
    <!--
      Static cue for holding general state.
    
      * $DebugChance
        - Int, 0 or 100.
      * $commands
        - Table of lists of subtables, commands recorded.
        - Outer table key is the command name.
        - List is each registered callback for that name (supports multiple).
        - Inner tables hold the command callback and echo.
    -->
    <cue name="Globals">
      <actions>
        <!-- Create storage table on first load. -->
        <set_value name="Globals.$storage"   exact="table[]"/>
        <include_actions ref="Reset_Globals"/>
      </actions>
      <cues>
        <!-- Listen for the menu api reloading. -->
        <cue name="Reset_On_Lua_Reload" instantiate="true">
          <conditions>
            <event_ui_triggered screen="'Simple_Menu'" control="'reloaded'" />
          </conditions>
          <actions>
            <!--<debug_text text="'Reloading'" chance="100" filter="general"/>-->
            <include_actions ref="Reset_Globals"/>
          </actions>
        </cue>
      </cues>
    </cue>
    <library name="Reset_Globals">
      <actions>
        <set_value name="Globals.$DebugChance" exact="0"/>
        <set_value name="Globals.$commands" exact="table[]" />
        <!-- Send a signal that all users listen to. -->
        <signal_cue_instantly cue="Reloaded"/>
      </actions>
    </library>

    <!--@doc-cue
    Cue signalled when the api is reloaded.
    Users that are registering commands should do so when this cue is signalled.
    -->
    <cue name="Reloaded" instantiate="true">
      <conditions>
        <event_cue_signalled />
      </conditions>
      <actions>
      </actions>
    </cue>

    <!--@doc-cue
      Print a line to the chat window. This will not evaluate the line as
      a command.
    -->
    <cue name="Print" instantiate="true">
      <conditions>
        <event_cue_signalled />
      </conditions>
      <actions>
        <!--The chat window could be handled by egosoft code or custom code. 
            TODO: maybe support ego control; needs care for the ; requirement.-->
        <!--<raise_lua_event name="'directChatMessageReceived'" param="event.param"/>-->
        <raise_lua_event name="'Chat_Window_API.Print'" param="event.param"/>
      </actions>
    </cue>
    
    
    <!--@doc-cue
      Cue signalled when text is entered into the chat window. Users may
      listen to this to capture all entered text, as an alternative to
      registering specific commands.
      
      Param is a table with two items:
      * $text
        - String, the raw text entered by the player.
        - Will always have at least one non-space character.
      * $terms
        - List of strings, the text space separated.
        - Multiple spaces in a row are treated as one space.
        - There will always be at least one item in the list.
        
      Note: aiscripts can instead listen to the ui signal directly:
      `<event_ui_triggered screen="'Chat_Window_API'" control="'text_entered'" />`
      with the text and terms in the event.param3 table.
    -->
    <cue name="Text_Entered" instantiate="true">
      <conditions>
        <event_cue_signalled />
      </conditions>
      <actions>
      </actions>
    </cue>

    
    <!--@doc-cue
    
    Add a new command to the chat window.  This is primarily for convenience,
    and can be skipped in favor of listening directly to Text_Entered.
    
    This should be called whenever the API signals md.Chat_Window_API.Reloaded.
      
    Input to this cue is a table with the following fields:
      * $name
        - String, text of the command. Does not need to start with '/'.
      * $callback
        - Cue to call when this command is entered.
        - See below for event.param contents.
      * $echo
        - Optional, anything (string, value, table, etc.), data to be
          attached to the callback cue param for convenience.
        
        
    The callback cue is given an event.param table with the following:
      * $name
        - Same as $name above.
      * $echo
        - Same as $echo above.
      * $terms
        - List of strings, space separated terms given by the player.
        - The first term is always the $name.
    
    Example:
    ```xml
    <cue name="Add_Commands" instantiate="true">
      <conditions>
        <event_cue_signalled cue="md.Chat_Window_API.Reloaded" />
      </conditions>
      <actions>
        <signal_cue_instantly
          cue="md.Chat_Window_API.Register_Command"
          param = "table[
              $name       = '/mytest',
              $callback   = Command_Callback,
              $echo       = table[],
            ]"/>
      </actions>
    </cue>
    ```
    -->
    <cue name="Register_Command" instantiate="true" namespace="this">
      <conditions>
        <event_cue_signalled />
      </conditions>
      <actions>
        <set_value name="$command" exact="event.param.clone" />

        <!--Error if no name given.-->
        <do_if value="not $command.$name?">
          <debug_text text="'Error: missing $name in command with args: %s'.[$command]"
                    chance="100" filter="general"/>
        </do_if>
        <!--Error if no callback given.-->
        <do_elseif value="not $command.$callback? or not $command.$callback.exists">
          <debug_text text="'Error: missing $callback in command with args: %s'.[$command]"
                    chance="100" filter="general"/>
        </do_elseif>
        
        <do_else>          
          <!--Default args.-->
          <do_if value="not $command.$echo?">
            <set_value name="$command.$echo" exact="null"/>
          </do_if>
          
          <!--Record it, making a new list if needed (generally will be).-->
          <set_value name="$key" exact="'$' + $command.$name"/>
          <do_if value="not Globals.$commands.{$key}?">
            <set_value name="Globals.$commands.{$key}" exact="[]"/>
          </do_if>
          <append_to_list name="Globals.$commands.{$key}" exact="$command"/>          
        </do_else>
      </actions>
    </cue>

    
    <!--
      Listen for text entry, hand off to Text_Entered, and handle command
      callbacks.
    -->
    <cue name="Lua_Signalled_Text_Entered" instantiate="true">
      <conditions>
        <event_ui_triggered screen="'Chat_Window_API'" control="'text_entered'" />
      </conditions>
      <actions>
        <signal_cue_instantly cue="Text_Entered"  param="event.param3"/>

        <!--<debug_text filter="general" text="'%s'.[event.param3]"/>-->
        
        <!--Check if the first term matches a registered command.-->
        <set_value name="$key" exact="'$' + event.param3.$terms.{1}"/>
        <do_if value="Globals.$commands.{$key}?">
          <do_for_each name="$command" in="Globals.$commands.{$key}">
            <do_if value="$command.$callback.exists">
              <signal_cue_instantly 
                cue="$command.$callback" 
                param="table[
                  $name   = $command.$name,
                  $echo   = $command.$echo,
                  $terms  = event.param3.$terms,
                ]"/>
            </do_if>
          </do_for_each>
        </do_if>
        
      </actions>
    </cue>

  </cues>

</mdscript>



<?xml version="1.0" encoding="utf-8" ?>
<mdscript name="Hotkey_API"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
<!--Note: keep the MD name convenient for users.-->

<!--@doc-title Hotkey API -->
<!--
MD API support for making custom hotkeys.
This makes use of the Named Pipe API and an external python server.
Python will handle keypress detection, and will transmit to this MD script
which in turn handles callbacks to user specified cues.

-->
  <!--
TODO:
  - Option to hide an action (make private) from the menu.
-->
<cues>

  <!-- ################################################################## -->
  <!--                              Init                                  -->
  <!-- ################################################################## -->

    
  <!-- Register the main lua file. -->
  <cue name="Load_Lua_Files" instantiate="true">
    <conditions>
      <event_ui_triggered screen="'Lua_Loader'" control="'Ready'" />
    </conditions>
    <actions>
      <raise_lua_event name="'Lua_Loader.Load'"
                        param="'extensions.sn_mod_support_apis.lua_hotkey_interface'"/>
    </actions>
  </cue>


  <!--
  Register the pipe server with the python host.
  -->
  <cue name="Register_Pipe_Server" instantiate="true">
    <conditions>
      <event_cue_signalled cue="md.Pipe_Server_Host.Reloaded" />
    </conditions>
    <actions>
      <signal_cue_instantly
        cue="md.Pipe_Server_Host.Register_Module"
        param="'extensions/sn_mod_support_apis/python_send_keys.txt'"/>
    </actions>
  </cue>

  <!--
      Text storage cue, for easier lookup in general.
      Members are descriptive names of the text strings, prefixed with $.
    -->
  <cue name="Text"/>
  <library name="Load_Text">
    <actions>
      <set_value exact="{68537, 1010}" name="Text.$Debug" />
      <set_value exact="{68537, 1021}" name="Text.$option_debug_enable" />
      <set_value exact="{68537, 1012}" name="Text.$option_debug_enable_mouseover" />
    </actions>
  </library>


  <!--
  Static cue that holds some shared state information or constants.
  When this script is installed, a new instance of this cue is created,
  and will afterwards be live until the script is removed.
  Globals reset each time the game is loaded, to enable easy changing
  of constants.
    
  * DebugChance
    - 0 or 100
    
  * action_registry
    - Table of tables, with each subtable describing an action.
    - Keys are the action ids.
    - See Register_Action for description of fields.
           
  * key_event_action_registry
    - Table, indexed by key/event descriptor (string), holding a list of
      action ids attached to it.
    - Descriptors are made up of the key combo string, followed by the
      name of an event type (onPress, etc.).
    - Key descriptors have an extra '$' prefixed, due to x4 quirkiness.
    - A action may be used in multiple entries if it is enabled for
      multiple events.
    - Normally expect only one action to be registered per key, but it
      might be higher.
    - May have a mix of player-assigned and mod-assigned links.
    - Keys with no registered cues should be removed.
    - If table is empty, no keys are being listened to.
    - Note: this may be filled during init prior to actions being
      registered, which is okay.
      
  * key_event_substrings
    - Table, keyed the same as key_event_action_registry, simply holding
      a two item list of [key_name, event_name], the key_event name
      components.
    - Purely for convenience, as an alternative to overcomplicating
      the above registry with table or list entries.
    - Will be allowed to grow beyond keys currently in use.
        
  * player_action_keys
    - Table of player assigned key descriptors, keyed by action id.
    - Saved across reloads.
    - Saving is done in md (naturally), and in lua using userdata.xml.
    - On lua reload, it will read userdata and send over the found keys
      if it wasn't empty, prior to signalling 'reloaded'.
    - TODO: drop support for md saving
    - Lua will have a mirrored copy of this, and is primarily responsible
      for changing it or initializing entries.
    - Note: a single action may have multiple keys (2 through ui).
    - Each entry is a subtable with:
      * id
        - String, action id.
      * inputs
        - List with two entries, subtables describing the key.
        - Indices match up to the menu columns (left/right), supporting two
          player keys per action.
        - Fields per subtable:
          * combo
            - String, pipe server understood key combo.
            - Generated from the ego code.
            - Currently, this is "code <source> <code> <signum>", to be
              unpacked in python.
          * code
            - Int, ego style key code.
            - See https://github.com/wgois/OIS/blob/master/includes/OISKeyboard.h
              for the code mapping.
          * source
            - Int, ego style input source type.  1 for keyboard.
          * signum
            - Int, ego style signum (signed prefix), generally 0.
            
  * menu_states
    - Table, keyed by menu name (as registered with ego backend), holding
      'true' if the menu is open, else 'false'.
    - Minimized menus will be treated as closed.
  * in_menu
    - Bool, true if the player has a menu open.
    - Updated whenever menu_states is changed, primarily to speedup checks
      during key handling.
  * in_protected_menu
    - Bool, true if the player is in a protected menu where actions
      are disabled globally.
    - Currently used for OptionsMenu, to menu-enabled actions causing
      problems when remapping keys.
  * disabled
    - Bool, true when the lua has requested hotkeys be disabled following
      a direct input event (eg. edit box text).
    - This will cause callbacks to be suppressed.
  -->
  <cue name="Globals">
    <!-- When first created, set up globals for the pipe handler. -->
    <actions>
      <include_actions ref="Reset_Globals"/>
    </actions>
    <cues>
      <!-- Reset when the lua reloads. -->
      <cue name="Reset_On_Lua_Reload" instantiate="true">
        <conditions>
          <event_ui_triggered screen="'Hotkey'" control="'reloaded'" />
        </conditions>
        <actions>
          
          <!--<debug_text text="'Reloading'" chance="100" filter="general"/>-->
          <include_actions ref="Reset_Globals"/>

          <!--Load in any saved userdata.-->
          <include_actions ref="Load_Userdata"/>
          
          <!-- Init the lua with the stored list of player keys. -->
          <set_value name="player.entity.$hotkey_api_player_keys_from_md" exact="$player_action_keys" />
          <raise_lua_event name="'Hotkey.Update_Player_Keys'"/>

          <!-- Send a signal that all users listen to. -->
          <signal_cue_instantly cue="Reloaded"/>
        </actions>
      </cue>
    </cues>
  </cue>

  <!-- TODO: can this lib be put into the cues list above? -->
  <library name="Reset_Globals">
    <actions>
      <!--Load any text.-->
      <include_actions ref="Load_Text"/>
      
      <set_value name="$action_registry" exact="table[]"/>
      <set_value name="$key_event_action_registry" exact="table[]"/>
      <set_value name="$key_event_substrings" exact="table[]"/>      
      <set_value name="$menu_states" exact="table[]"/>
      <set_value name="$in_menu" exact="false"/>
      <set_value name="$in_protected_menu" exact="false"/>
      <set_value name="$disabled" exact="false"/>

      <!-- TODO: somehow bounce this over to Server_Reader reliably.-->
      <set_value name="$DebugChance" exact="0" />

      <!-- Init the $player_action_keys if it doesn't exist. -Moved to userdata.
      <do_if value="not $player_action_keys?">
        <set_value name="$player_action_keys" exact="table[]"/>
      </do_if> -->
        
    </actions>
  </library>

  <!--Load in userdata, which is shared across saves.
      Values saves in userdata:
      - Globals.$player_action_keys
  -->
  <library name="Load_Userdata">
    <actions>
      <!--Set the default to init empty entries.-->
      <run_actions ref="md.Userdata.Read" result="$userdata">
        <param name="Owner" value="'sn_mod_support_apis'"/>
        <param name="Key" value="'hotkey_api'"/>
        <param name="Default" value="table[
                       $player_action_keys = table[],
                       ]"/>
      </run_actions>      
      <!--Extract fields.-->
      <set_value name="Globals.$player_action_keys" exact="$userdata.$player_action_keys"/>
    </actions>
  </library>

  <!--Trigger a lua update of userdata, setting it to save to uidata.xml.-->
  <library name="Update_Userdata">
    <actions>
      <run_actions ref="md.Userdata.Write">
        <param name="Owner" value="'sn_mod_support_apis'"/>
        <param name="Key" value="'hotkey_api'"/>
        <param name="Value" value="table[
               $player_action_keys = Globals.$player_action_keys,
               ]"/>
      </run_actions>
    </actions>
  </library>
    


  <!-- ################################################################## -->
  <!--                          Pipe Handling                             -->
  <!-- ################################################################## -->

  <!-- 
  Use the generic server reader library to handle the pipe.
  Needs a cue wrapping it, else get property errors on the library refs.
    -->
  <cue name="Server_Reader_Wrapper">
    <cues>
      <cue name="Server_Reader" ref="md.Pipe_Server_Lib.Server_Reader">
        <param name="Actions_On_Reload"   value="Actions_On_Reload"/>
        <param name="Actions_On_Connect"  value="Actions_On_Connect"/>
        <param name="Actions_On_Read"     value="Actions_On_Read"/>
      </cue>
    </cues>
  </cue>

  <library name="Actions_On_Reload">
    <actions>
      <!--TODO: how to get debugchance from Globals safely on first mod load.-->
      <set_value name="$Pipe_Name" exact="'x4_keys'" />
      <set_value name="$DebugChance" exact="0" />

      <!-- Make sure the read loop is started if there are keys tracked. -->
      <do_if value="md.Hotkey_API.Globals.$key_event_action_registry.keys.list.count != 0">
        <signal_cue cue="$Start_Reading" />
      </do_if>
      <!-- Disable the menu plugin. -->
      <raise_lua_event name="'Hotkey.Update_Connection_Status'" param="0"/>
    </actions>
  </library>
  
  <library name="Actions_On_Connect">
    <actions>
      <!-- Announce the wanted keys to the server. -->
      <signal_cue_instantly cue="md.Hotkey_API.Register_Keys_With_Server"/>
      <!-- Enable the menu plugin. -->
      <raise_lua_event name="'Hotkey.Update_Connection_Status'" param="1"/>
    </actions>
  </library>

  <!--TODO: break out the key handling from the pipe cue.-->
  <library name="Actions_On_Read">
    <actions>
      <!-- Bounce back to lua to separate the message. 
          TODO: somehow avoid the lua bounce and related frame delay;
          perhaps extend the pipe api to support a generic lua processing
          function automated as part of the read?
      -->
      <raise_lua_event name="'Hotkey.Process_Message'" param="event.param"/>
      <!--<signal_cue_instantly cue="md.Hotkey_API.Handle_Message" param="event.param"/>-->

      <!--Acknowledge this key was read.
        Note: this will not bother to check for errors. If the pipe dies,
        a read will fail and catch it. -->
      <signal_cue_instantly
        cue="md.Named_Pipes.Write"
        param="table[$pipe=$Pipe_Name, $msg='ack']"/>
    </actions>
  </library>


  <!-- Function to update the server list of registered keys. -->
  <cue name="Register_Keys_With_Server" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    
    <actions>
      <!-- Suppress if not connected to server, to reduce log confusion. -->
      <do_if value="Server_Reader.$server_connected == 1">

        <!--Start by merging the keys together, semicolon separated. -->
        <set_value name="$joined_keys" exact="''" />
        <do_all exact="Globals.$key_event_action_registry.keys.list.count" counter="$i">
          <set_value name="$joined_keys"
            exact="$joined_keys + Globals.$key_event_action_registry.keys.list.{$i} + ';'"/>
        </do_all>

        <!-- Send this to the server. -->
        <signal_cue_instantly
          cue="md.Named_Pipes.Write"
          param="table[$pipe = Server_Reader.$Pipe_Name, $msg = 'setkeys:'+$joined_keys ]"/>

      </do_if>
    </actions>
  </cue>
    

  <!-- ################################################################## -->
  <!--                           User API                                 -->
  <!-- ################################################################## -->


  <!--@doc-cue
  Dummy cue used for signalling that the api reloaded.
  Users that are registering actions should listen to this
  cue being signalled.
  -->
  <cue name="Reloaded" instantiate="true">
    <conditions>
      <event_cue_signalled />
    </conditions>
    <actions>
    </actions>
  </cue>

  <!--@doc-cue
    Function to register an action. These actions will be displayed
    in the api options menu for user assignment of a hotkey.
    This should be re-sent each time Reloaded is signalled.
    
    Param : Table with the following items:
    * id
      - String, unique identifier of this action.
      - Saved keys will map to ids; other fields may be changed.
    * name = id
      - String, name to use for the key in the menu.
      - If not given, defaults to the id.
    * description = ""
      - String, mouseover text use for the key in the menu.
    * category = null
      - String, optional category heading to use in the menu.
      - Hotkeys are displayed by sorted categories first, then sorted
        names.
    * onPress = null
      - Callback cue when the combo final key is pressed.
    * onRelease = null
      - Callback cue when the combo final key is released.
    * onRepeat = null
      - Callback cue when the combo final key is repeated while held.
      - Repeat delay and rate depend on OS settings.
    * echo
      - Anything; this will be passed to the callback cue.
    * contexts
      - List of strings, names of player contexts where the action is valid.
      - If not given, defaults to "['flying']".
      - Valid contexts:
        * 'flying'
          - While the player is piloting a ship.
        * 'walking'
          - While the player is on foot.
        * 'menus'
          - While the player is in any menu.
          - The OptionsMenu will be protected, with actions always disabled.
        * ...
          - Other entries are names of individual menus, as registered by
            the egosoft backend.
                
    Keypress events will return a table with these fields:
    * key
      - String, identifier of the key combination matched.
    * id
      - Matching id of the action. May be useful if one callback cue handles
        multiple actions.
    * context
      - String, the player context when this action was triggered.
      - Either one of ["flying", "walking", "menu"], or the name of the
        open menu matching an entry in menu_names.
    * event
      - String, name of the event that occured.
      - One of ["onPress", "onRelease", "onRepeat"].
    * echo
      - Copy of what was given to the action registration, or null.
    
    Usage example:
      ```xml
      <cue name="Register_Action" instantiate="true">
        <conditions>
          <event_cue_signalled cue="md.Hotkey_API.Reloaded" />
        </conditions>
        <actions>
          <signal_cue_instantly 
            cue = "md.Hotkey_API.Register_Action" 
            param="table[
              $id          = 'my_key',
              $onPress     = OnKeyPress,
              $name        = 'Test Key',
              $description = 'This key is just testing',
              $contexts    = ['flying','walking'],
              ]"/>
        </actions>
      </cue>
      ```
  -->
  <cue name="Register_Action" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>

    <actions>
      <set_value name="$args" exact="event.param"/>
      
      <!-- TODO: maybe try this syntax for defaults.
      <do_for_each name="$key" valuename="$default" 
                   in="table[
                    $description   = '',
                    $contexts      = ['flying'],
                   ]">
        <set_value name="$args.{$key}" exact="if ($args.{$key}?) then $args.{$key} else $default"/>
      </do_for_each> -->
      
      <!-- Default args. -->
      <do_if value="not $args.$description?">
        <set_value name="$args.$description" exact="''"/>
      </do_if>
      <do_if value="not $args.$name?">
        <set_value name="$args.$name" exact="$args.$id"/>
      </do_if>
      <do_if value="not $args.$contexts?">
        <set_value name="$args.$contexts" exact="['flying']"/>
      </do_if>
      <do_if value="not $args.$echo?">
        <set_value name="$args.$echo" exact="null"/>
      </do_if>

      <!-- For easier usage, split standard and menu contexts. -->
      <!-- Any misc menu names are collected into a separate list. 
          This is done so at usage time, menu name checks can be more
          easily ignored if no names were given. -->
      <set_value name="$contexts" exact="[]"/>
      <set_value name="$menu_names" exact="[]"/>
      <!-- Convenience table keyed with standard context names to check. -->
      <set_value name="$std_contexts" exact="['flying','walking','menus']"/>

      <!-- Loop over the given list. -->
      <do_for_each name="$name" in="$args.$contexts">
        <!-- Check for standard names. -->
        <do_if value="$std_contexts.indexof.{$name} != 0">
          <append_to_list name="$contexts" exact="$name"/>
        </do_if>
        <!-- Otherwise this should be a menu name. -->
        <do_else>
          <append_to_list name="$menu_names" exact="$name"/>
        </do_else>
      </do_for_each>
      
      <!-- Store the new data format. -->
      <set_value name="$args.$contexts"   exact="$contexts"/>
      <!-- If menu_names is an empty list, ignore it. -->
      <do_if value="$menu_names.count ge 0">
        <set_value name="$args.$menu_names" exact="$menu_names"/>
      </do_if>
      
      <!-- Record it. -->
      <set_value name="Globals.$action_registry.{'$'+$args.$id}" exact="$args"/>
      <debug_text text="'Action %s registered with args: %s'.[$args.$id, $args]"
                  chance="Globals.$DebugChance" filter="general"/>
      
      <!-- If any player keys were saved for this action, apply them now. -->
      <do_if value="Globals.$player_action_keys.{'$'+$args.$id}?">
        <set_value name="$info" exact="Globals.$player_action_keys.{'$'+$args.$id}"/>
        <!-- Loop over the input list; up to 2 combos. -->
        <do_for_each name="$input" in="$info.$inputs">
          <!-- Skip if the combo is blank. -->
          <do_if value="$input.$combo != ''">
            <signal_cue_instantly cue="Register_Key" param="table[
                                  $id  = $info.$id,
                                  $key = $input.$combo, 
                                  ]"/>
          </do_if>
        </do_for_each>
      </do_if>
        
      <!-- Keep the lua updated. -->
      <!-- Passes it on a player blackboard var, which lua clears. -->
      <set_value name="player.entity.$hotkey_api_actions" exact="Globals.$action_registry" />
      <raise_lua_event name="'Hotkey.Update_Actions'"/>
      
      <!--Note: if this is the first registered action, at this point the action
          is registered, but a key is not set, and the server hasn't been
          connected (since it looks for actual keys to be registered).
          However, logic exists to suppress the menu hotkey displays if there
          is no connected server, to reduce confusion slightly.
          So, start the server connection now, regardless of registered keys,
          to find out if it can even make a connection, after which the menu
          to set hotkeys can be displayed.
          (This isn't needed once keys are registered and remembered, but
          does apply to new games or new installs of the extension.)
          -->
      <signal_cue cue="Server_Reader.$Start_Reading" />
    </actions>
  </cue>


  <!--@doc-cue
  
    Function to register a key with an action.
    
    If this is the first key registered, it will start the key listening loop.
    This is used by the menu system to set up player custom keys, but may
    also be called by a user to directly assign a key to an action.
    Keys added by direct user calls will not be visible in the menu, and have
    fewer restrictions than the menu enforces.
    This should be re-sent each time Reloaded is signalled, and should follow
    the action's registration.
    
    Param  : Table with the following items:
    * key
      - String specifying the key/combo to capture.
    * id
      - String, id of the matching action sent to Register_Action.
      - The action should already exist.
      
    Usage example:
      ```xml
      <cue name="Register_Keys" instantiate="true">
        <conditions>
          <event_cue_signalled cue="md.Hotkey_API.Reloaded" />
        </conditions>
        <actions>
          <signal_cue_instantly 
            cue="md.Hotkey_API.Register_Key" 
            param="table[$key='shift w', $id='my_registered_key']"/>
        </actions>
      </cue>
      ```
    
    Key syntax:
    - Keys may be given singular or as a combination.
    - Combinations are space separated.
    - A combo is triggered when the last key is pressed while all prior keys
      are held.
      - Examples:
      - "shift ctrl k" : 'shift' and 'ctrl' held when 'k' pressed.
      - "space 5" : 'space' held when '5' pressed
    - Shift, alt, ctrl act as modifiers.
      - TODO: remove alt as a modifier, to better match x4 behavior.
    - Alphanumeric keys use their standard character.
    - Special keys use these names (from pynput with some additions):
      - alt
      - alt_l
      - alt_r
      - backspace
      - caps_lock
      - ctrl
      - ctrl_l
      - ctrl_r
      - delete
      - down
      - end
      - enter
      - esc
      - f1 - f20
      - home
      - insert
      - left
      - menu
      - num_lock
      - page_down
      - page_up
      - pause
      - print_screen
      - right
      - scroll_lock
      - shift
      - shift_l
      - shift_r
      - space
      - tab
      - up
      - num_0
      - num_1
      - num_2
      - num_3
      - num_4
      - num_5
      - num_6
      - num_7
      - num_8
      - num_9
      - num_.
      - num_+
      - num_-
      - num_*
      - num_/
      - num_enter
      - win_l
      - win_r

  -->
  <cue name="Register_Key" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>

    <actions>
      <!--<debug_text text="'params: %s.'.[event.param]" chance="Globals.$DebugChance" filter="general"/>-->

      <!-- Validate that a string was sent. Removed; buggy, typeof thinks some chars are not strings.
      <do_if value="(typeof event.param.$key) != datatype.string">
        <debug_text text="'Error, given key is not a string: %1'.[event.param.$key]"
                    chance="100" filter="error"/>
      </do_if> -->
       
      <!-- Adjust the key to prefix with a $ for x4 tables. -->
      <set_value name="$key" exact="'$' + event.param.$key"/>
      <set_value name="$id" exact="event.param.$id"/>
      
      <!-- Look up the action; error if not found. -->
      <set_value name="$action" exact="Globals.$action_registry.{'$' + $id}"/>

      <!-- Loop over possible event types; each gets its own entry. -->
      <do_for_each name="$event" in="['onPress','onRelease','onRepeat']">
        <!-- Skip if the action doesn't use this event. -->
        <do_if value="not $action.{'$' + $event}?">
          <continue/>
        </do_if>
        <!-- Create the full key, by suffixing with event type. -->
        <set_value name="$key_event" exact="$key +' '+ $event"/>
              
        <!-- Make sure there is a table entry for the key. -->
        <do_if value="not Globals.$key_event_action_registry.{$key_event}?">
          <set_value name="Globals.$key_event_action_registry.{$key_event}" exact="[]"/>
          <!-- Record the key (no $) and event name for later lookup. -->
          <set_value name="Globals.$key_event_substrings.{$key_event}" exact="[event.param.$key, $event]"/>
        </do_if>

        <!-- Check if the id is already recorded for this key. -->
        <do_if value="Globals.$key_event_action_registry.{$key_event}.indexof.{$id} != 0">
          <!-- Print some warning. -->
          <debug_text text="'Warning, action %s already registered to key %s'.[$id, $key_event]"
                      chance="Globals.$DebugChance" filter="general"/>
        </do_if>
        <do_else>
          <!-- It isn't recorded, so add it in. -->
          <append_to_list name="Globals.$key_event_action_registry.{$key_event}" exact="$id" />
          <debug_text text="'Action %s registered to key %s'.[$id, $key_event]"
                      chance="Globals.$DebugChance" filter="general"/>
        </do_else>
        
      </do_for_each>

      <!-- Update the server. If it isn't connected, ignore any error. -->
      <signal_cue_instantly cue="Register_Keys_With_Server"/>

      <!-- Make sure the read loop is started, if it wasn't already. -->
      <signal_cue cue="Server_Reader.$Start_Reading" />
    </actions>
  </cue>


  <!--@doc-cue  
    Function to unregister a key from an action.     
    Params are the same as for Register_Key.
        
    Usage example:
      ```xml
        <signal_cue_instantly 
          cue="md.Hotkey_API.Unregister_Key" 
          param="table[$key='shift w', $id='my_registered_key']"/>
      ```
  -->
  <cue name="Unregister_Key" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>

    <actions>
      <set_value name="$key" exact="'$' + event.param.$key"/>
      <set_value name="$id" exact="event.param.$id"/>

      <!-- Look up the action; error if not found. -->
      <set_value name="$action" exact="Globals.$action_registry.{'$' + $id}"/>

      <!-- Loop over possible event types; each gets its own entry. -->
      <do_for_each name="$event" in="['onPress','onRelease','onRepeat']">
        <!-- Skip if the action doesn't use this event. -->
        <do_if value="not $action.{'$' + $event}?">
          <continue/>
        </do_if>
        <!-- Create the full key, by suffixing with event type. -->
        <set_value name="$key_event" exact="$key + ' ' + $event"/>

        <!-- Check if there is no table entry for the key. -->
        <do_if value="not Globals.$key_event_action_registry.{$key_event}?">
          <!-- Print some warning. -->
          <debug_text text="'Warning, key %s has no registered actions'.[$key_event]"
                      chance="Globals.$DebugChance" filter="general"/>
          <continue/>
        </do_if>
      
        <!-- Check if the id is recorded for this key. -->
        <set_value name="$id_index" exact="Globals.$key_event_action_registry.{$key_event}.indexof.{$id}"/>
        <do_if value="$id_index == 0">
          <!-- It isn't recorded, so print a warning. -->
          <debug_text text="'Warning, action %s is not registered to key %s'.[$id, $key_event]"
                      chance="Globals.$DebugChance" filter="general"/>
          <continue/>
        </do_if>

        <!-- Proceed with removal. -->
        <remove_value name="Globals.$key_event_action_registry.{$key_event}.{$id_index}" />
        <debug_text text="'Removed action %s from key %s'.[$id, $key_event]"
                    chance="Globals.$DebugChance" filter="general"/>

        <!-- Check if the key's cue list is empty, and remove it if so. -->
        <do_if value="Globals.$key_event_action_registry.{$key_event}.count == 0">
          <remove_value name="Globals.$key_event_action_registry.{$key_event}" />
          <debug_text text="'No remaining listeners to key %s; removing it'.[$key_event]"
                      chance="Globals.$DebugChance" filter="general"/>
        </do_if>
      </do_for_each>

      <!-- Update the server. If it isn't connected, ignore any error. -->
      <signal_cue_instantly cue="Register_Keys_With_Server"/>
      
    </actions>
  </cue>



  <!-- ################################################################## -->
  <!--                          Lua events                                -->
  <!-- ################################################################## -->
  
  <!--
    Capture lua signal on a direct-input event key press.
    This happens when the player is entering text into a text box,
    eg. the chat window, ship renaming, etc.
    
    The lua side will first send a "disable" event, wait some period of
    time, then send an "enable" event. The goal is that any corresponding
    hotkey matches should be received in the window and suppressed.
    
    Note: this solution isn't perfect, and may suppress a legit hotkey
    entered right after finishing with an edit box (relatively low impact),
    or may allow a direct input key to match a hotkey if there is a large
    latency hiccup between server and local handler.
    TODO: think about more robust ways to suppress keys under latency.
  -->
  <cue name="Capture_Lua_Disable" instantiate="true" namespace="this">
    <conditions>
      <event_ui_triggered screen="'Hotkey'" control="'disable'" />
    </conditions>
    <actions>
      <!--<raise_lua_event name="'directChatMessageReceived'" param="'KeyCapture;disabling...'"/>-->
      <set_value name="Globals.$disabled" exact="true"/>
    </actions>
  </cue>

  <cue name="Capture_Lua_Enable" instantiate="true" namespace="this">
    <conditions>
      <event_ui_triggered screen="'Hotkey'" control="'enable'" />
    </conditions>
    <actions>
      <!--<raise_lua_event name="'directChatMessageReceived'" param="'KeyCapture;enabling...'"/>-->
      <set_value name="Globals.$disabled" exact="false"/>
    </actions>
  </cue>
  

  <!--
    Capture lua signals when the player assigns a new key.
      
    Lua's passed param will be a table with:
    * new_key
      - New key combo, or blank string.
    * old_key
      - Prior key combo, or blank string.
    * id
      - Action id
  -->
  <cue name="Capture_Lua_Key_Update" instantiate="true" namespace="this">
    <conditions>
      <event_ui_triggered screen="'Hotkey'" control="'Update_Key'" />
    </conditions>

    <actions>
      <!-- Rename the args. -->
      <set_value name="$args" exact="event.param3" />
      <debug_text text="'Args: %s'.[$args]" chance="Globals.$DebugChance" filter="general"/>

      <!-- If there was a prior key, unregister it. -->
      <do_if value="$args.$old_key != ''">
        <signal_cue_instantly cue="Unregister_Key" 
                              param="table[$key=$args.$old_key, $id=$args.$id]"/>
      </do_if>

      <!-- If there is a new key, register it. -->
      <do_if value="$args.$new_key != ''">
        <signal_cue_instantly cue="Register_Key" 
                              param="table[$key = $args.$new_key, $id = $args.$id]"/>
      </do_if>

    </actions>
  </cue>


  <!--
    Capture lua signals to store the list of player keys.
    Generally called at the same time as Update_Key, but kept separate
    for now.
    The keys are passed on the player blackboard.
  -->
  <cue name="Capture_Lua_Store_Player_Keys" instantiate="true" namespace="this">
    <conditions>
      <event_ui_triggered screen="'Hotkey'" control="'Store_Player_Keys'" />
    </conditions>
    <actions>
      <set_value name="Globals.$player_action_keys" 
                 exact="player.entity.$hotkey_api_player_keys_from_lua"/>
      <remove_value name="player.entity.$hotkey_api_player_keys_from_lua"/>      
      <!--Make sure the userdata is updated to store the keys.-->
      <include_actions ref="Update_Userdata"/>
    </actions>
  </cue>

  <!--
    Capture menu open/close events.
    This updates menu_states and in_menu.
  -->
  <library name="Lib_Update_Menu_Status">
    <actions>
      <!--Set the flag false initially, back to true on any menu open.-->
      <set_value name="Globals.$in_menu" exact="false"/>
      <set_value name="Globals.$in_protected_menu" exact="false"/>
      
      <do_all exact="Globals.$menu_states.keys.list.count" counter="$i">
        <set_value name="$key" exact="Globals.$menu_states.keys.list.{$i}"/>
        
        <!-- Check if this menu is open. -->
        <do_if value="Globals.$menu_states.{$key}">
          <set_value name="Globals.$in_menu" exact="true"/>
          
          <!--<raise_lua_event name="'directChatMessageReceived'" param="'KeyCapture;Menu open: %s'.[$key]"/>-->
          
          <!-- Check if the protected options menu is open. -->
          <do_if value="$key == 'OptionsMenu'">
            <set_value name="Globals.$in_protected_menu" exact="true"/>
          </do_if>
          
        </do_if>
      </do_all>
      <!--<debug_text text="'Globals.$in_menu = %1'.[Globals.$in_menu]"
                  chance="Globals.$DebugChance" filter="general"/>-->
    </actions>
  </library>
  
  <cue name="Capture_Lua_Menu_Opened" instantiate="true" namespace="this">
    <conditions>
      <event_ui_triggered screen="'Hotkey'" control="'Menu_Opened'" />
    </conditions>
    <actions>
      <set_value name="Globals.$menu_states.{'$'+event.param3}" exact="true"/>
      <include_actions ref="Lib_Update_Menu_Status"/>
    </actions>
  </cue>
  
  <cue name="Capture_Lua_Menu_Closed" instantiate="true" namespace="this">
    <conditions>
      <event_ui_triggered screen="'Hotkey'" control="'Menu_Closed'" />
    </conditions>
    <actions>
      <set_value name="Globals.$menu_states.{'$'+event.param3}" exact="false"/>
      <include_actions ref="Lib_Update_Menu_Status"/>
    </actions>
  </cue>
    

  <!-- ################################################################## -->
  <!--                         Key Press Handling                         -->
  <!-- ################################################################## -->
  
  <!--
    Handle key press events.
    The python originally packaged these together to reduce signal overhead
    (after key repetition got sluggish as separate messages), so a single
    message handles all keys in a period of time.
    A list of key combos should be in the event.param3.
  -->
  <cue name="Handle_Events" instantiate="true" namespace="this">
    <conditions>
      <event_ui_triggered screen="'Hotkey'" control="'handle_events'" />
    </conditions>
    <actions>
      <!-- Read succeeded with at least one key. -->
      <!-- Handle callback cues. -->
      <do_for_each name="$key_event" in="event.param3">
        <!-- Start by prefixing the key combo with a '$' for table lookups.
            Removed; done in lua.
        <set_value name="$key_event" exact="'$' + event.param"/> -->              

        <debug_text text="'Received key event %s'.[$key_event]"
                    chance="Globals.$DebugChance" filter="general"/>
        <!--<raise_lua_event name="'directChatMessageReceived'" param="'KeyCapture;Received key event %s'.[$key_event]"/>-->
      
        <!-- Ignore if currently in a protected menu. -->
        <do_if value="Globals.$in_protected_menu">
          <debug_text text="'Ignoring key; protected menu open'"
                      chance="Globals.$DebugChance" filter="general"/>
          <!--<raise_lua_event name="'directChatMessageReceived'" param="'KeyCapture;Ignoring key; protected menu open'"/>-->
        </do_if>
      
        <!--Ignore if disabled after direct input.-->
        <do_elseif value="Globals.$disabled">
          <debug_text text="'Ignoring key; temporarily disabled after direct text input'"
                      chance="Globals.$DebugChance" filter="general"/>
          <!--<raise_lua_event name="'directChatMessageReceived'" param="'KeyCapture;Ignoring key; direct input disabled'"/>-->
        </do_elseif>

        <!-- Is the key returned actually registered? -->
        <do_elseif value="Globals.$key_event_action_registry.{$key_event}?">
        
          <!-- Determine the current player context. -->
          <!-- TODO: maybe pack into chained if/then/else expression. -->
          <!-- If any menu is open, then in a menu. -->
          <do_if value="Globals.$in_menu">
            <set_value name="$context" exact="'menus'"/>
          </do_if>
          <!-- Otherwise if piloting a ship, then flying. -->
          <do_elseif value="player.occupiedship">
            <set_value name="$context" exact="'flying'"/>
          </do_elseif>
          <!-- Otherwise walking around. -->
          <do_else>
            <set_value name="$context" exact="'walking'"/>
          </do_else>

          <debug_text text="'Context of key: %s'.[$context]"
                      chance="Globals.$DebugChance" filter="general"/>
          <!--<raise_lua_event name="'directChatMessageReceived'" param="'KeyCapture;Context of key: %s'.[$context]"/>-->
        
          <!-- Get the event associated with this key/event, matching its suffix. -->
          <set_value name="$key" exact ="Globals.$key_event_substrings.{$key_event}.{1}"/>
          <set_value name="$event" exact ="Globals.$key_event_substrings.{$key_event}.{2}"/>
        
          <!-- Loop over the action ids. -->
          <do_for_each name="$id" in="Globals.$key_event_action_registry.{$key_event}">
          
            <!-- Get the actual action info. -->
            <set_value name="$action" exact="Globals.$action_registry.{'$' + $id}"/>
          
            <!-- Determine if this action is valid at this time. -->
            <set_value name="$valid" exact="false"/>
          
            <!-- General context check. -->
            <do_if value="$action.$contexts.indexof.{$context} != 0">
              <set_value name="$valid" exact="true"/>
            </do_if>
          
            <!-- If in menu and menu names were given, check specific name. -->
            <do_elseif value="Globals.$in_menu and ($action.$menu_names?)">
              <!-- Go through all menu names and see if any are open. -->
              <do_for_each name="$menu_name" in="$action.$menu_names">
                <!--Check this is a tracked menu, and in an open state.-->
                <do_if value="Globals.$menu_states.{$menu_name}? and Globals.$menu_states.{$menu_name}">
                  <!-- This menu is open, so flag as valid. -->
                  <set_value name="$valid" exact="true"/>
                  <!-- Update the context for cue callback. -->
                  <set_value name="$context" exact="$menu_name"/>
                  <break/>
                </do_if>
              </do_for_each>
            </do_elseif>
          
            <!-- Skip if not a valid context. -->
            <do_if value="not $valid">
              <debug_text text="'Skipping due to context mismatch'"
                          chance="Globals.$DebugChance" filter="general"/>
              <continue/>
            </do_if>
          
            <!-- Look up the cue to callback to. -->
            <!-- (In the current setup, the cue should always be found.) -->
            <set_value name="$cue" exact="@$action.{'$'+$event}"/>
          
            <!-- Call it if it still exists. -->
            <do_if value="$cue.exists">
              <debug_text text="'Signalling cue: %s'.[$cue]"
                          chance="Globals.$DebugChance" filter="general"/>
              <!--<raise_lua_event name="'directChatMessageReceived'" param="'KeyCapture;Signalling cue: %s'.[$cue]"/>-->
              <!-- Call the cue, with return values. -->
              <signal_cue_instantly cue="$cue" param="table[
                                    $key     = $key,
                                    $id      = $id,
                                    $context = $context,
                                    $event   = $event,
                                    $echo    = $action.$echo
                                    ]"/>
            </do_if>
            <!-- TODO: delink keys from non-existent actions/cues. -->
            <!--Could do this by removing the $event from the action, 
                unregistering, and reregistering.-->          
          </do_for_each>
        </do_elseif>

        <do_else>
          <!-- Key not registered. TODO: error message. -->
          <debug_text text="'Ignoring key; no registered events'"
                      chance="Globals.$DebugChance" filter="general"/>
        </do_else>
      </do_for_each>
    </actions>
  </cue>


  <!-- Set up a menu option to turn on/off the debug logging. -->
  <cue name="Set_Menu_Options" instantiate="true">
    <conditions>
      <event_cue_signalled cue="md.Simple_Menu_Options.Reloaded"/>
    </conditions>
    <actions>
      <!--TODO: maybe hide this unless in developer mode (how to know?)-->
      <signal_cue_instantly
        cue="md.Simple_Menu_Options.Register_Option"
        param = "table[
            $category   = Text.$Debug,
            $id         = 'debug_hotkey_api',
            $name       = Text.$option_debug_enable,
            $mouseover  = Text.$option_debug_enable_mouseover,
            $default    = 0,
            $type       = 'button',
            $callback   = On_Option_Change,
            ]"/>
    </actions>
  </cue>

  <cue name="On_Option_Change" instantiate="true">
    <conditions>
      <event_cue_signalled />
    </conditions>
    <actions>
      <set_value name="$id"    exact="event.param.$id"/>
      <set_value name="$value" exact="event.param.$value"/>

      <do_if value="$id == 'debug_hotkey_api'">
        <!-- Change the debug chance in the main md file. -->
        <set_value name="Globals.$DebugChance"
                   exact ="if ($value) then 100 else 0"/>
      </do_if>
    </actions>
  </cue>


</cues>
</mdscript><?xml version="1.0" encoding="utf-8" ?>
<mdscript name="Interact_Menu_API" 
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" >
  <!--Note: keep the MD name convenient for users.-->

  <!-- @doc-title MD Interact Menu API -->

  <!-- @doc-overview
  MD API support for working with interaction menus (eg. right-click context
  menus). Listen for Get_Actions being signalled when a menu opens,
  check conditions and add relevant actions with Add_Actions, wait for
  callbacks if a player selects a custom action.
  -->
  
    
  <cues>

    <!-- Register the main lua file. -->
    <cue name="Load_Lua_Files" instantiate="true">
      <conditions>
        <event_ui_triggered screen="'Lua_Loader'" control="'Ready'" />
      </conditions>
      <actions>
        <raise_lua_event name="'Lua_Loader.Load'"
                         param="'extensions.sn_mod_support_apis.lua_interact_menu_interface'"/>
      </actions>
    </cue>

    <!--
      Text storage cue, for easier lookup in general.
      Members are descriptive names of the text strings, prefixed with $.
    -->
    <cue name="Text"/>
    <library name="Load_Text">
      <actions>
        <set_value exact="{68537, 1010}" name="Text.$Debug" />
        <set_value exact="{68537, 1040}" name="Text.$option_disable_name" />

        <set_value exact="{68537, 1041}" name="Text.$option_debug_enable" />
        <set_value exact="{68537, 1012}" name="Text.$option_debug_enable_mouseover" />
      </actions>
    </library>
    
    
    <!--Set up extension options.-->
    <cue name="Setup_Options" instantiate="true">
      <conditions>
        <event_cue_signalled cue="md.Simple_Menu_Options.Reloaded"/>
      </conditions>
      <actions>
        <include_actions ref="Load_Text"/>

        <!--Logging enable.-->
        <signal_cue_instantly
          cue="md.Simple_Menu_Options.Register_Option"
          param = "table[
            $category   = Text.$Debug,
            $id         = 'debug_interact_api',
            $name       = Text.$option_debug_enable,
            $mouseover  = Text.$option_debug_enable_mouseover,
            $default    = 0,
            $type       = 'button',
            $callback   = On_Option_Change,
            ]"/>
        
        <!--Disable the api, in case a patch breaks it.-->
        <signal_cue_instantly
          cue="md.Simple_Menu_Options.Register_Option"
          param = "table[
            $category   = Text.$Debug,
            $id         = 'disable_interact_api',
            $echo       = 'disabled',
            $name       = Text.$option_disable_name,
            $default    = 0,
            $type       = 'button',
            $callback   = On_Option_Change,
            ]"/>
      </actions>
    </cue>
    
    <!--Handle option changes.-->
    <cue name="On_Option_Change" instantiate="true">
      <conditions>
        <event_cue_signalled />
      </conditions>
      <actions>
        <!--Handle md-level options.-->
        <do_if value="event.param.$id == 'debug_interact_api'">
          <set_value name="Globals.$DebugChance"
                     exact ="if (event.param.$value) then 100 else 0"/>
        </do_if>

        <do_else>
          <!--Pass down to any matching lua level option.
            $echo is the setting name in lua. -->
          <set_value name="$args" exact="table[
                   $command  = 'Update_Settings',
                   $setting  = event.param.$echo,
                   $value    = event.param.$value,
                   ]"/>
          <include_actions ref="Send_Command"/>
        </do_else>      
      </actions>
    </cue>
    
    <!--
      Static cue for holding general state.
    
      * $DebugChance
        - Int, 0 or 100.
      * $actions
        - Table of subtables, actions recorded in registration order.
        - Keyed by action id.
        - Action subtable contents described in Register_Action or Add_Action.
      * $menu_params
        - Table of polished data sent from lua to md holding various menu
          params set when a menu was opened.
        - Used for temporary storage between menu opening and a user callback.
    -->
    <cue name="Globals">
      <actions>
        <!-- Create storage table on first load. -->
        <set_value name="Globals.$storage"   exact="table[]"/>
        <include_actions ref="Reset_Globals"/>
      </actions>
      <cues>
        <!-- Listen from the menu api reloading. -->
        <cue name="Reset_On_Lua_Reload" instantiate="true">
          <conditions>
            <event_ui_triggered screen="'Interact_Menu_API'" control="'reloaded'" />
          </conditions>
          <actions>
            <!--<debug_text text="'Reloading'" chance="100" filter="general"/>-->
            <include_actions ref="Reset_Globals"/>
          </actions>
        </cue>
      </cues>
    </cue>
    <library name="Reset_Globals">
      <actions>
        <set_value name="Globals.$DebugChance" exact="0"/>
        <set_value name="Globals.$actions" exact="table[]" />
        <set_value name="Globals.$menu_params" exact="table[]"/>
        <!-- Send a signal that all users listen to. -->
        <signal_cue_instantly cue="Reloaded"/>        
      </actions>
    </library>

    <!--Shared code for sending a command to lua.
        Input:
        * $args
          - Table with any command args, as well as the $command string.
    -->
    <library name="Send_Command">
      <actions>
        <!-- Args are transmitted to lua using a blackboard var. -->
        <!-- Create the blackboard list if it doesn't exist. -->
        <do_if value="not player.entity.$interact_menu_args?">
          <set_value name="player.entity.$interact_menu_args" exact="[]" />
        </do_if>
        <append_to_list name="player.entity.$interact_menu_args" exact="$args"/>

        <debug_text text="'Sending %s with args: %s'.[$args.$command, $args]"
                  chance="Globals.$DebugChance" filter="general"/>

        <!-- Signal the lua function. -->
        <raise_lua_event name="'Interact_Menu.Process_Command'"/>
      </actions>
    </library>

    <!--Shared code for recording an action, and passing to lua.
        Input:
        * $action
    -->
    <library name="Record_Action">
      <actions>
        <!--Record the args, mainly for callbacks.-->
        <set_value name="Globals.$actions.{'$' + $action.$id}" exact="$action"/>
        <set_value name="$args" exact="$action"/>
        <!--TODO: debug print it.-->
        <include_actions ref="Send_Command"/>
      </actions>
    </library>


    <!-- ################################################################## -->
    <!--                             User Cues                              -->
    <!-- ################################################################## -->


    <!--@doc-cue
      Cue used to signal when a new menu is being opened, and actions
      may be added.
      
      The cue event.param holds a table with target data:
      * $object
        - The object the action was selected for, eg. a ship. 
      * $texts
        - Table with several text strings used in context menus.
        - Possible fields are described further below, in the Texts section.
      * <various params>
        - Other menu parameters are included and described further below,
          in the Params section.
    -->
    <cue name="Get_Actions" instantiate="true">
      <conditions>
        <event_cue_signalled />
      </conditions>
      <actions>
      </actions>
    </cue>

    
    <!--@doc-cue
    
    Add an action to a newly created interact menu. This should be called
    just following a menu opening event, signalled from lua, holding
    info on the target object. These actions are removed from the menu
    after it closes, and need to be re-added on the next menu opening.
    
    This should be called whenever the API signals 
    md.Interact_Menu_API.Get_Actions with target data.
      
    Input to this cue is a table with the following fields:
      * $id
        - String, unique identifier for this action.
      * $text
        - String, text to display in the action menu, left column.
      * $icon
        - String, optional name of an icon to prefix before the text.
      * $text2
        - String, optional text to display in the right column.
        - Support for this varies with $section. Eg. 'main' supports text2
          while 'interaction' does not.
      * $mouseover
        - String, optional text to display on menu widget mouseover.
      * $mouseover_icon
        - String, optional name of an icon to prefix before the mouseover text.
      * $section = 'main'
        - Optional string, the menu section this action will go under.
        - Should be one from menu_interactmenu.lua config.sections.
        - TODO: Document these somewhat.
        - For now, just use "main" or "interaction".
      * $callback
        - Cue to call when the player selects the action.
        - See below for event.param contents.
      * $keep_open
        - Bool, if the menu should be left open after this action is selected.
        - Defaults false, closing the menu.
      * $active
        - Bool, if false then the action will be greyed out and unselectable.
        - Defaults true.
      * $echo
        - Optional, anything (string, value, table, etc.), data to be
          attached to the callback cue param for convenience.
        
        
    The callback cue returns an event.param table with the following:
      * $id
        - Same as $id above.
      * $echo
        - Same as $echo above.
      * $object
        - The object the action was selected for, eg. a ship.
        - Possibly null.
        - This is the same as in Get_Actions.
      * [params]
        - Other menu parameters are included and described further below,
          in the Params section.
        - These are the same as in Get_Actions.
      * $texts
        - Table with several text strings used in context menus.
        - Possible fields are described further below, in the Texts section.
        - These are the same as in Get_Actions.
    
    Example:
    ```xml
    <cue name="Add_Interact_Actions" instantiate="true">
      <conditions>
        <event_cue_signalled cue="md.Interact_Menu_API.Get_Actions" />
      </conditions>
      <actions>
        <set_value name="$target" exact="event.param.$object"/>
        <do_if value="$target.isclass.{class.ship}">
          <signal_cue_instantly
            cue="md.Interact_Menu_API.Add_Action"
            param = "table[
                $id         = 'my_action_id',
                $text       = 'Do Something',
                $icon       = 'order_follow',
                $callback   = Interact_Callback,
              ]"/>
        </do_if>
      </actions>
    </cue>
    ```
    -->
    <cue name="Add_Action" instantiate="true" namespace="this">
      <conditions>
        <event_cue_signalled />
      </conditions>
      <actions>
        <set_value name="$action" exact="event.param.clone" />

        <!--Error if no id given.-->
        <do_if value="not $action.$id?">
          <debug_text text="'Error: missing $id in action with args: %s'.[$action]"
                    chance="100" filter="general"/>
        </do_if>

        <do_else>
          <!--Add the lua command.-->
          <set_value name="$action.$command" exact="'Add_Action'"/>

          <!--Default args.-->
          <do_if value="not $action.$text?">
            <set_value name="$action.$text" exact="$action.$id"/>
          </do_if>
          <do_if value="not $action.$echo?">
            <set_value name="$action.$echo" exact="null"/>
          </do_if>
          <do_if value="not $action.$section?">
            <set_value name="$action.$section" exact="'main'"/>
          </do_if>
          <do_if value="not $action.$keep_open?">
            <set_value name="$action.$keep_open" exact="false"/>
          </do_if>
          <do_if value="not $action.$mouseover?">
            <set_value name="$action.$mouseover" exact="''"/>
          </do_if>
          
          <!--Record it.-->
          <include_actions ref="Record_Action"/>
        </do_else>
      </actions>
    </cue>


    <!--@doc-cue
    
    Updates fields of a currently recorded action. Note: currently this
    will not update a displayed menu's actions, since those are determined
    when the  menu is first drawn.
      
    Input to this cue is a table with the following fields:
      * $id
        - String, unique identifier matching an existing action.
      * [params]
        - Other params should match existing ones, and will overwrite them.
    
    Example:
    ```xml
    <signal_cue_instantly
      cue="md.Interact_Menu_API.Update_Action"
      param = "table[
          $id         = 'my_action_id',
          $callback   = Other_Callback_Cue,
        ]"/>
    ```
    -->
    <cue name="Update_Action" instantiate="true" namespace="this">
      <conditions>
        <event_cue_signalled />
      </conditions>
      <actions>
        <set_value name="$args" exact="event.param" />

        <!--Error if no id given, or doesn't match a recording.-->
        <do_if value="not $args.$id?">
          <debug_text text="'Error: missing $id in action with args: %s'.[$args]"
                    chance="100" filter="general"/>
        </do_if>
        <do_else>
          <set_value name="$key" exact="'$' + $args.$id"/>
          <do_if value="not Globals.$actions.{$key}?">
            <debug_text text="'Error: Update_Action $id %s does not match existing actions.'.[$args.$id]"
                      chance="100" filter="general"/>
          </do_if>
          <do_else>        
            <!--Update md stored values, eg. if a callback changes.-->
            <do_for_each name="$field" valuename="$value" in="$args">
              <set_value name="Globals.$actions.{$key}.{$field}" exact="$value"/>
            </do_for_each>
        
            <!--Pass the updated values to lua, after attaching a command.-->
            <set_value name="$args.$command" exact="'Update_Action'"/>
            <include_actions ref="Send_Command"/>
          </do_else>
        </do_else>
      </actions>
    </cue>

    <!-- ################################################################## -->
    <!--                       Depricated Static Action                     -->
    <!-- ################################################################## -->

    <!--@doc-cue
    Dummy cue used for signalling that this api reloaded.
    Users that are registering options should listen to this
    cue being signalled.
    Somewhat depricated in favor of Get_Actions.
    -->
    <cue name="Reloaded" instantiate="true">
      <conditions>
        <event_cue_signalled />
      </conditions>
      <actions>
        <debug_text text="'Reloaded'"
                  chance="Globals.$DebugChance" filter="general"/>

      </actions>
    </cue>

    <!--@doc-cue
    
    Register a new context menu action. If the action already exists,
    it will be updated with the new arguments. These actions are persistent,
    and will be checked every time the menu options for condition matches.
    
    Note: slightly depricated in favor of Add_Action.
      
    This should be called whenever the API signals md.Interact_Menu_API.Reloaded
      
    Input is a table with the following fields:
      * $id
        - String, unique identifier for this action.
      * $text
        - String, text to display in the action menu.
      * $icon
        - String, optional name of an icon to prefix before the name.
        - Typical order icons are 32x32, though any icon given will be
          scaled to 32 height.
      * $section = 'main'
        - Optional string, the menu section this action will go under.
        - Should be one from menu_interactmenu.lua config.sections.
        - TODO: Document these somewhat.
        - For now, just use "main" or "interaction".
      * $enabled_conditions
        - List of strings, flag names understood by the backend, of which
          at least one must be True to enable the action.
      * $disabled_conditions
        - List of strings, flag names understood by the backend, of which
          all must be False to enable the action.
      * $mouseover
        - String, text to display on menu widget mouseover.
      * $callback
        - Cue to call when the player selects the action.
        - See below for event.param contents.
      * $echo
        - Optional, anything (string, value, table, etc.), data to be
          attached to the callback cue param for convenience.
      * $disabled = 0
        - Optional, 0 or 1; if the option will not be displayed in the menu.
        
        
    The callback cue returns an event.param table with the following:
      * $id
        - Same as $id above.
      * $echo
        - Same as $echo above.
      * $object
        - The object the action was selected for, eg. a ship.
    
    
    The flags available for matching include the following. All are strings,
    and may be negated by a prefixed '~', eg. '~isenemy'.
      * Component class
        - class_controllable
        - class_destructible
        - class_gate
        - class_ship
        - class_station
      * Component data
        - is_dock
        - is_deployable
        - is_enemy
        - is_playerowned
      * Menu flags
        - show_PlayerInteractions
          - Menu flagged to show player interactions.
        - has_PlayerShipPilot
          - Selection is a player ship and has a pilot.
      * Misc
        - is_operational
          - Selection is operational?
        - is_inplayersquad
          - Selection is in the player's squad.
        - has_pilot
          - Selection has a pilot.
        - have_selectedplayerships
          - Selection(s) include one or more player ships.
      * Player related
        - player_is_piloting
          - True if the player is piloting a ship.
        - is_playeroccupiedship
          - Selection is the player's ship.
      
      
    Example:
    ```xml
    <cue name="Reset_On_Reload" instantiate="true">
      <conditions>
        <event_cue_signalled cue="md.Interact_Menu_API.Reloaded"/>
      </conditions>
      <actions>
        <signal_cue_instantly
          cue="md.Interact_Menu_API.Register_Action"
          param = "table[
            $id         = 'some_unique_id',
            $section    = 'main',
            $name       = 'My Action',
            $callback   = My_Callback_Cue,
            $mouseover  = '',
            $enabled_conditions  = ['show_PlayerInteractions'],
            $disabled_conditions = [],
            ]"/>
      </actions>
    </cue>
    ```
    -->
    <cue name="Register_Action" instantiate="true" namespace="this">
      <conditions>
        <event_cue_signalled />
      </conditions>
      <actions>
        <set_value name="$action" exact="event.param.clone" />

        <!--Error if no id given.-->
        <do_if value="not $action.$id?">
          <debug_text text="'Error: missing $id in action with args: %s'.[$action]"
                    chance="100" filter="general"/>
        </do_if>

        <do_else>
          <!--Add the lua command.-->
          <set_value name="$action.$command" exact="'Register_Action'"/>

          <!--Default args.-->
          <!--This used to take $name instead of $text.-->
          <do_if value="$action.$name? and not $action.$text?">
            <set_value name="$action.$text" exact="$action.$name"/>
          </do_if>
          <do_if value="not $action.$text?">
            <set_value name="$action.$text" exact="$action.$id"/>
          </do_if>
          <do_if value="not $action.$echo?">
            <set_value name="$action.$echo" exact="null"/>
          </do_if>
          <do_if value="not $action.$section?">
            <set_value name="$action.$section" exact="'main'"/>
          </do_if>
          <do_if value="not $action.$keep_open?">
            <set_value name="$action.$keep_open" exact="false"/>
          </do_if>
          <do_if value="not $action.$disabled?">
            <set_value name="$action.$disabled" exact="0"/>
          </do_if>
          <do_if value="not $action.$enabled_conditions?">
            <set_value name="$action.$enabled_conditions" exact="[]"/>
          </do_if>
          <do_if value="not $action.$disabled_conditions?">
            <set_value name="$action.$disabled_conditions" exact="[]"/>
          </do_if>
          <do_if value="not $action.$mouseover?">
            <set_value name="$action.$mouseover" exact="''"/>
          </do_if>

          <!--Record it.-->
          <include_actions ref="Record_Action"/>
        </do_else>
      </actions>
    </cue>

    <!-- ################################################################## -->
    <!--                          Lua callbacks                             -->
    <!-- ################################################################## -->

    <!--
    Listen for the lua signals when the menu is opened.
    -->
    <cue name="Capture_Lua_Display" instantiate="true" namespace="this">
      <conditions>
        <event_ui_triggered screen="'Interact_Menu_API'" control="'onDisplay'" />
      </conditions>
      <actions>
        <!--The table will largely be used as-is.-->
        <set_value name="$menu_params" exact="event.param3"/>
        <!--Error check for bad table (may be null due to conversion error).
            In such cases, expect a AddUITriggeredEvent releated error in
            the debug log, so don't print an error message here.-->
        <do_if value="typeof $menu_params == datatype.table">
        
          <!--Convert select lua object ids to their md components.-->
          <do_for_each name="$field" in="['$object', '$offsetcomponent', '$construction']">
            <do_if value="$menu_params.{$field}?">
              <!--Convert 0 to null explicitly. (Component lookup will also 
                  return null, but with a log error)-->
              <do_if value="$menu_params.{$field} == 0">
                <set_value name="$menu_params.{$field}" exact="null"/>
              </do_if>
              <do_else>
                <set_value name="$menu_params.{$field}" exact="component.{$menu_params.{$field}}"/>
              </do_else>
            </do_if>
          </do_for_each>
        
          <!--Loop over lists, if present.-->
          <do_for_each name="$field" in="['$selectedplayerships', '$selectedplayerdeployables', '$selectedotherobjects']">
            <do_if value="$menu_params.{$field}?">
              <do_for_each name="$ship_id" in="$menu_params.{$field}">
                <set_value name="$menu_params.{$field}.{loop.index}" exact="component.{$ship_id}"/>
              </do_for_each>                         
            </do_if>
          </do_for_each>
        
          <!--Convert an offset position to an md Position.-->
          <do_if value="$menu_params.$offset?">
            <set_value name="$menu_params.$offset" exact="position.[
                       $menu_params.$offset.$x,
                       $menu_params.$offset.$y,
                       $menu_params.$offset.$z,
                       ]"/>
          </do_if>
        
          <!--Convert 0/1 to bool true/false.-->
          <do_for_each name="$field" in="['$isshipconsole', '$isdockedship', '$showPlayerInteractions', '$hasPlayerShipPilot']">
            <set_value name="$menu_params.{$field}" exact="if $menu_params.{$field} == 1 then true else false"/>
          </do_for_each>
        
          <!--TODO: what other conversions are needed?-->
        
          <!--Store this data to repeat later for a possible callback cue, so
              the lua doesn't have to send it twice.-->
          <set_value name="Globals.$menu_params" exact="$menu_params"/>
        
          <do_if value="Globals.$DebugChance">
            <signal_cue_instantly cue="Debug_Print_Params"/>
          </do_if>
        
          <!--Signal this locally to a dummy cue, that users can listen to.-->
          <signal_cue_instantly cue="Get_Actions" param="$menu_params"/>
        </do_if>
      </actions>
    </cue>

    <!--
      For debug, print out the menu parameters received.
    -->
    <cue name="Debug_Print_Params" instantiate="true" namespace="this">
      <conditions>
        <event_cue_signalled />
      </conditions>
      <actions>
        <set_value name="$msg" exact="'Menu Params:'"/>
        
        <!--Loop over the fields.-->
        <do_for_each name="$key" valuename="$value" in="Globals.$menu_params">
          
          <!--Expand lists to get object names.-->
          <do_if value="typeof $value == datatype.list">
            <do_for_each name="$value2" in="$value">
              <set_value name="$msg" exact="'\n  %s[%s] : %s (%s%s)'.[
                        $key, 
                        loop.index, 
                        if $value2.name? then $value2.name else $value2,
                        typeof $value2,
                        if $value2.class? then ', %s'.[$value2.class] else '',
                        ]"
                        operation="add"/>
            </do_for_each>
          </do_if>

          <!--Expand tables similarly.-->
          <do_elseif value="typeof $value == datatype.table">
            <do_for_each name="$key2" valuename="$value2" in="$value">
              <set_value name="$msg" exact="'\n  %s[%s] : %s (%s%s)'.[
                          $key, 
                          $key2, 
                          if $value2.name? then $value2.name else $value2,
                          typeof $value2,
                          if $value2.class? then ', %s'.[$value2.class] else '',
                          ]"
                          operation="add"/>
            </do_for_each>
          </do_elseif>
          
          <!--Loose fields.-->
          <do_else>
            <set_value name="$msg" exact="'\n  %s : %s (%s%s)'.[$key, 
                      if $value.name? then $value.name else $value,
                      typeof $value,
                      if $value.class? then ', %s'.[$value.class] else '',
                      ]"
                         operation="add"/>
          </do_else>
        </do_for_each>

        <debug_text text="$msg + '\n'" filter="general"/>
      </actions>
    </cue>
    
    <!--
    Listen for the lua signals when an option is selected.
    -->
    <cue name="Capture_Lua_Callback" instantiate="true" namespace="this">
      <conditions>
        <event_ui_triggered screen="'Interact_Menu_API'" control="'Selected'" />
      </conditions>
      <actions>        
        <!--Look up the action by id to get the callback.-->
        <set_value name="$action" exact="Globals.$actions.{'$' + event.param3.$id}"/>

        <debug_text text="'Action: %s on %s'.[
                            event.param3.$id, 
                            Globals.$menu_params.$object,]"
                  chance="Globals.$DebugChance" filter="general"/>

        <!--Handle the callback, if it is still valid.-->
        <!--Note: need to cast the object into an MD suitable component.-->
        <do_if value="$action.$callback? and $action.$callback.exists">
          
          <!--Make a copy of the menu params to return.
              These params may be used again, eg. if the action doesn't
              close the menu, so the copy is safe against user edits.-->
          <set_value name="$params" exact="Globals.$menu_params.clone"/>
          
          <!--Populate with id and echo.-->
          <set_value name="$params.$id" exact="$action.$id"/>
          <set_value name="$params.$echo" exact="$action.$echo"/>
          
          <signal_cue_instantly cue="$action.$callback" param="$params"/>
        </do_if>
      </actions>
    </cue>

    <!-- ################################################################## -->
    <!--                             Extra Docs                             -->
    <!-- ################################################################## -->
    <!--Note: put these inside cues, due to doc gen parsing top level then cue level.-->

    <!--@doc-section    
    #### Params
    
    When an interact menu is opened, various parameters on the target object
    and the source object(s) are populated, and used to guide which actions
    will show and what to do when actions are taken. A version of these
    params will be polished for MD usage, and passed to the event.param
    of Get_Actions and any action callback cues.
    
    The possible params are as follows. Not all of these will exist for
    every target type.
         
    * $object
      - Target object, or possibly a parent of the target.
      - When selecting a spot on a map, may be a sector.
      - May be null, eg. when opening a context menu for a mission.
    * $isshipconsole
      - Bool, True if the target is a ship console.
      - This includes when the player selects the console at a docking pad.
    * $isdockedship
      - Bool, True if a ship console is open at a dock with a docked ship.
      - If True, the $object will be the docked ship.
      - If False for a ship console, it indicates the console is for an empty
        dock, and $object is that dock.
    * $selectedplayerships
      - List of player ships that are currently selected.
      - This is often populated by default with the player-piloted ship
        if the $object isn't the player ship.
    * $showPlayerInteractions
      - Bool, True if the menu wants to show player interactions with the object.
      - Convenience term that gets set when $selectedplayerships is a list
        with only the player occupied ship in it.
      - Typically true when the player opens an interact menu on another
        object while flying.
    * $hasPlayerShipPilot
      - Bool, True if a ship in $selectedplayerships has an assigned pilot
        and is not the player occupied ship.
      - This will always be False if $showPlayerInteractions is True.
    * $selectedplayerdeployables
      - List of player deployables that are currently selected.
    * $selectedotherobjects
      - List of other objects that are currently selected, eg. ships
        and stations.
    * $order_queueidx
      - Int, index of an order in the queue, if target is an order.
      - May be unspecified.
    * $subordinategroup
      - Int, 1-24, matches the corresponding greek letter of a selected
        subordinate group.
      - May be unspecified.
    * $construction
      - Object under construction, which the menu opened on.
      - This occurs in the map view, looking at a shipyard, right clicking
        on a ship under construction, in which case the $object is the
        shipyard and $construction is the ship.
      - May be unspecified.
    * $mission
      - ID of an active mission, as a cdata string representation.
      - May be unspecified.
    * $missionoffer
      - ID of a mission offer, as a cdata string representation.
      - May be unspecified.
    * $componentMissions
      - Potentially a list of mission ids (untested), as cdata strings.
      - May be unspecified.
    * $offsetcomponent
      - Reference object for a position targeted, often a sector.
      - May be unspecified.
    * $offset
      - Position offset from $offsetcomponent of a target.
      - May be unspecified.
    -->

    <!--@doc-section
    #### Texts
    
    In lua, various potentially useful text strings are created based on
    the target and selected objects. They are passed over to md in the
    Get_Actions event.param, and listed here. Note: many of these fields
    may not exist for a given target.
    
    * $targetShortName
      - Name of the target.
      - This should always be present.
      - Missions and mission offers will lack any other text.
    * $targetName
      - Name of the target with color prefix, object id, and other fields
        as applicable (eg. gate destination).
    * $targetBaseName
      - Ships only, the short base ship name.
    * $targetBaseOrShortName
      - Either $targetBaseName if defined, else $targetShortName.
      - This should always be present.
      - Vanilla actions often use $targetBaseName if available,
        else $targetShortName, as text2; this is a convenience
        term added to mimic that behavior.
    * $commanderShortName
      - Objects with commanders only, commander name.
    * $commanderName
      - Objects with commanders only, command name with sector prefix
        and if, as applicable.
    * $selectedName
      - If player ships selected, the name of the ship (if one) or
        an indicator of number of ships selected.
    * $selectedFullNames
      - If player ships selected, names of all ships separated by
        newlines, suitable for mouseover.
    * $selectedNameAll
      - If object is player owned ship, the count of selected ships
        including the menu target.
    * $selectedFullNamesAll
      - As $selectedFullNames, but including the target object.
    * $otherName
      - As $selectedName, but for selected other objects (not ships).
    * $otherFullNames
      - As $selectedFullNames, but for selected other objects (not ships).
    * $constructionName
      - Construction only, name of the construction.
    * $buildstorageName
      - Build storage only, name of the build storage.
    
    -->
    
    <!--@doc-section    
    #### Sections and subsections
    
    The following is a quick listing of the different context menu sections
    and subsections an action can be added to. Actions in a subsection will
    show in the expanded menu on mouseover.
    
    * main
    * interaction
    * hiringbuilderoption
      - hiringbuilder
    * trade
    * playersquad_orders
    * main_orders
    * formationshapeoption
      - formationshape
    * main_assignments
    * main_assignments_subsections
      - main_assignments_defence
      - main_assignments_attack
      - main_assignments_interception
      - main_assignments_supplyfleet
      - main_assignments_mining
      - main_assignments_trade
      - main_assignments_tradeforbuildstorage
    * order
    * guidance
    * player_interaction
    * consumables
      - consumables_civilian
      - consumables_military
    * cheats
    * selected_orders_all
    * selected_orders
    * mining_orders
      - mining
    * venturedockoption
      - venturedock
    * trade_orders
    * selected_assignments_all
    * selected_assignments
      - selected_assignments_defence
      - selected_assignments_attack
      - selected_assignments_interception
      - selected_assignments_supplyfleet
      - selected_assignments_mining
      - selected_assignments_trade
      - selected_assignments_tradeforbuildstorage
    * selected_consumables
      - selected_consumables_civilian
      - selected_consumables_military
    * shipconsole
    
    Sections have a couple special properties, which relate to when a
    section's actions will be shown. They are listed here, to better
    indicate when each section will be shown.
    
    * isorder
      - Relates to if a section is shown when player ships are selected.
      - true:
        - selected_orders_all, selected_orders, mining_orders, 
          venturedockoption, trade_orders, selected_assignments_all,
          selected_assignments, selected_consumables
      - false:
        - main, interaction, hiringbuilderoption, trade, playersquad_orders,
          main_orders, formationshapeoption, main_assignments, 
          main_assignments_subsections, player_interaction, consumables, 
          cheats, shipconsole
      - undefined:
        - order, guidance
    * isplayerinteraction
      - Shown when a single player-owned ship is selected, and the player
        occupies it.
      - true:
        - guidance, player_interaction
      - undefined:
        - all other categories
    
    -->
    
  </cues>

</mdscript>



<?xml version="1.0" encoding="utf-8" ?>
<mdscript name="Lua_Loader" 
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <!--Note: keep the MD name convenient for users.-->

<cues>
  
  <!-- Tell the lua side that the game loaded. -->
  <cue name="Reload_Listener" instantiate="true" namespace="this">
    <conditions>
      <check_any>
        <event_game_loaded/>
        <event_game_started/>
      </check_any>
    </conditions>    
    <actions>
      <raise_lua_event name="'Lua_Loader.Send_Priority_Ready'"/>
    </actions>
  </cue>

  <!--Wait for lua side to send the Priority_Ready, and trigger normal Ready.-->
  <cue name="Send_Ready" instantiate="true" namespace="this">
    <conditions>
      <event_ui_triggered screen="'Lua_Loader'" control="'Priority_Ready'" />
    </conditions>
    <actions>
      <raise_lua_event name="'Lua_Loader.Send_Ready'"/>
    </actions>
  </cue>

</cues>

</mdscript><?xml version="1.0" encoding="utf-8" ?>
<mdscript name="Named_Pipes" 
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" >
  <!--Note: keep the MD name convenient for users. TODO: append API?-->

<!-- @doc-title MD Named Pipe API -->
  
<!-- @doc-overview
MD API support for working with named pipes for inter-process communication.
An external server (eg. written in Python) will create an OS named pipe,
and this api will connect to it as a client.
This will tie into related functions in an accompanying lua script.

Note: lua module supports only Windows named pipes.

Goals:
 - Allow user to access one or more named pipes, with arbitrary names.
 - Handle pipe write and read requests, in a non-blocking manner.
 - Recover safely on game save/reload, server shutdown/restart, ui reload, etc.
  
Operation notes:
 - The actual OS level pipe connections are handled in lua.
 - Minimal global state is tracked here; each access cue is self-sufficient.
 - Read/Write requests kick off cue instances that schedule the operation
   with the lua code, and then listen for a lua callback, ui reload (which
   wipes lua state), or timeout.
 - At least 1 frame of delay occurs on returning an operation result from
   lua back to md.
 - A user-supplied callback cue is called when access completes.
 - Any access error returns a special message to the callback cue.
 - Any pipe error will trigger an error on all pending accesses.
 - Such pipe errors will occur on game reloading, ui reload, server shutdown.
    
Usage:
 - See Read and Write cues below for how to call them.
 - User code should expect errors to occur often, and handle as needed.
 - Exact message protocol and transaction behavior depends on the external
   server handling a specific pipe.
 - If the OS pipe gets broken, the server should shutdown and remake
   the pipe, as the lua client cannot reconnect to the old pipe
   (in testing so far).
 - If passing rapid messages, recommend finding a way to join them together
   into one, or else have multiple read requests in flight at once, to
   avoid throttling due to the 1 frame lua->md delay.
    
Note on timeouts:
 - If an access times out in the MD, it will still be queued for service
   in the lua until the pipe is closed.
 - This is intentional, so that if the server is behaving correctly but
   tardy, writes and reads will still get serviced in the correct
   order.
-->
<!--
TODO:
 - Test through multiple save/reloads.
 - Add Transact function (convenient write+read, lower overhead).
 - Maybe rename lua call signals to prefix with Named_Pipes.
-->
<cues>

  <!-- Setting up the Lua side of this test. -->
  <cue name="Load_Lua_Files" instantiate="true">
    <conditions>
      <event_ui_triggered screen="'Lua_Loader'" control="'Ready'" />
    </conditions>
    <actions>
      <raise_lua_event name="'Lua_Loader.Load'" 
                       param="'extensions.sn_mod_support_apis.lua_named_pipes_interface'"/>
    </actions>
  </cue>

  <!--
      Text storage cue, for easier lookup in general.
      Members are descriptive names of the text strings, prefixed with $.
    -->
  <cue name="Text"/>
  <library name="Load_Text">
    <actions>
      <set_value exact="{68537, 1030}" name="Text.$Named_Pipes_API" />
      <set_value exact="{68537, 1031}" name="Text.$connected" />
      <set_value exact="{68537, 1032}" name="Text.$disconnected" />
      <set_value exact="{68537, 1033}" name="Text.$Pipe" />
      <set_value exact="{68537, 1034}" name="Text.$Status" />
      <set_value exact="{68537, 1035}" name="Text.$pipe_mouseover" />
      <set_value exact="{68537, 1036}" name="Text.$status_mouseover" />
    </actions>
  </library>


  <!--
    Static cue that holds some shared state information or constants.
    When this script is installed, a new instance of this cue is created,
    and will afterwards be live until the script is removed.
    Globals reset each time the game is loaded, to enable easy changing
    of constants.
    
    Attributes:          
    * access_counter
      - Int, number of accesses performed, with some rollover.
      - Used to tag each new access, so that the lua can suffix its
        completion signals to match them to the right callback cue.
        
    * reserved_ids
      - Table of reserved access ids. Values are dummy 1s.
      - Continuous reads will reserve their id to avoid conflict after
        rollover.
                
    * $pipe_name_prefix
      - String, prefix to add to all pipe names to construct the OS path.
      - On windows, this is "\\.\pipe\"
      - Not used; prefix attached in lua to simplify some signalling.
      
    * $pipe_status_cues
      - List of registered top level cues handling specific pipes.
      - Used for menu display.
      - Filled by calls to Register_Menu_Entry when Reloaded is signalled.
  -->  
  <cue name="Globals">
    <!-- When first created, set up globals. -->
    <actions>
      <!--Skip if Reset_On_Lua_Reload already set these up.-->
      <do_if value="not Globals.$DebugChance?">
        <include_actions ref="Reset_Globals"/>
      </do_if>
    </actions>
  </cue>
  
  <library name="Reset_Globals">
    <actions>
      <!--Load any text.-->
      <include_actions ref="Load_Text"/>
      
      <!-- Counter reset is optional, but include for init. -->
      <set_value name="Globals.$access_counter" exact="0"/>
      <set_value name="Globals.$reserved_ids" exact="table[]"/>
      <!-- Prefix to add to all pipe names. -->
      <set_value name="Globals.$pipe_name_prefix" exact="'\\\\.\\pipe\\'" />
      <set_value name="Globals.$pipe_status_cues" exact="[]"/>
      <!-- Debug printout chance; generally 0 or 100; ego style naming. -->
      <set_value name="Globals.$DebugChance" exact="0" />
    </actions>
  </library>
      
  <!--
    Reset some vars and send a signal when the lua reloads.
    This will happen on savegame reloads as well, since those trigger
    the lua loading which in turn sends this ui event signal.
    (Note: the lua signal will always arrive after md cues are set up,
    since it gets delayed by the Lua_Loader call.)
  -->
  <cue name="Reset_On_Lua_Reload" instantiate="true">
    <conditions>
      <event_ui_triggered screen="'Named_Pipes'" control="'reloaded'" />
    </conditions>
    <actions>
      <!--<debug_text text="'Reloading'" chance="100" filter="general"/>-->
      <!-- Make sure the global registry is reset. -->
      <include_actions ref="Reset_Globals"/>
      <!--Send a signal that all users listen to, to repopulate the table. 
          Instant, to avoid possible problems with delaying this.
      -->
      <signal_cue_instantly cue="Reloaded"/>
    </actions>
  </cue>  
  
  <!--@doc-cue
    Dummy cue used for signalling.
  -->  
  <cue name="Reloaded" instantiate="true">
    <conditions>
      <event_cue_signalled />
    </conditions>
    <actions>
    </actions>
  </cue>


  <!--
    Support lib function to update the access_counter, and use it
    to generate an ID string for the next access.
    Count rolls over every 10000 to limit the string size to 4 characters,
    and should be enough that an ID will not be reused until well after the
    prior access of that ID completed.
    
    Add to an action block using:
    <include_actions ref="Get_Next_Access_ID"/>
    Result is returned in: $access_id
  -->
  <library name="Get_Next_Access_ID">
    <actions>
      <!-- Inc with rollover. -->
      <set_value name="Globals.$access_counter" exact="1" operation="add"/>
      <do_if value="Globals.$access_counter >= 10000">
        <set_value name="Globals.$access_counter" exact="0"/>
      </do_if>
      <!--If this is reserved, keep going.-->
      <do_while value="Globals.$reserved_ids.{Globals.$access_counter}?">
        <set_value name="Globals.$access_counter" exact="1" operation="add"/>
        <do_if value="Globals.$access_counter >= 10000">
          <set_value name="Globals.$access_counter" exact="0"/>
        </do_if>        
      </do_while>
      <!-- Assign the new count to the access_id, as a string. -->
      <set_value name="$access_id" exact="'' + Globals.$access_counter"/>
    </actions>
  </library>

  
  <!--
    Send a command to lua, storing args in the player blackboard.
    The blackboard will use a list to queue multiple args for the same
    frame, since lua will process them in the latter part of the frame.
  -->
  <cue name="Send_Command" instantiate="true">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <!-- Args are transmitted to lua using a blackboard var. -->
      <!-- Create the blackboard list if it doesn't exist. -->
      <do_if value="not player.entity.$pipe_api_args?">
        <set_value name="player.entity.$pipe_api_args" exact="[]" />
      </do_if>
      <append_to_list name="player.entity.$pipe_api_args" exact="event.param"/>

      <debug_text text="'Sending %s to %s'.[event.param.$command, event.param.$pipe_name]"
                  chance="Globals.$DebugChance" filter="general"/>
      <raise_lua_event name="'pipeProcessCommand'"/>
    </actions>
  </cue>


  <!--@doc-cue
    
    User function to write a pipe.
    
    Param: Table with the following items:
    * pipe
      - Name of the pipe being written, without OS path prefix.
    * msg
      - Message string to write to the pipe.
    * cue
      - Callback, optional, the cue to call when the write completes.
    * time
      - Timeout, optional, the time until an unsent read is cancelled.
      - Currently not meaningful, as write stalling on a full pipe
        is not supported at the lua level.
      
    Returns:
    - Result is sent as event.param to the callback cue.
    - Writes receive 'SUCCESS' or 'ERROR'.
    
    Usage example:
    ```xml
      <signal_cue_instantly 
        name="md.Named_Pipes.Write" 
        param="table[
          $pipe='mypipe', 
          $msg='hello', 
          $cue=Write_Callback]">
    ```
  -->
  <cue name="Write" instantiate="true">
    <conditions>
      <event_cue_signalled/>
    </conditions>    
    <actions>
      <!-- Add the command to the param table, and pass it along. -->
      <set_value name="event.param.{'$command'}" exact="'Write'" />
      <signal_cue_instantly cue="Access_Handler" param="event.param"/>
    </actions>
  </cue>
  
  
  <!--@doc-cue
  
    As Write, but sends a special command in the message to the lua, which
    determines the actual message to send.  The only currently supported
    command is "package.path", which sends the current lua package import
    path list.
    
    Usage example:
    ```xml
      <signal_cue_instantly 
        name="md.Named_Pipes.Write_Special" 
        param="table[
          $pipe='mypipe', 
          $msg='package.path', 
          $cue=Write_Callback, 
          $time=5s]">
    ```
  -->
  <cue name="Write_Special" instantiate="true">
    <conditions>
      <event_cue_signalled/>
    </conditions>    
    <actions>
      <!-- Add the command to the param table, and pass it along. -->
      <set_value name="event.param.{'$command'}" exact="'WriteSpecial'" />
      <signal_cue_instantly cue="Access_Handler" param="event.param"/>
    </actions>
  </cue>
  
  
  <!--@doc-cue
    User function to read a pipe. Note: the lua-to-md frame delay means
    that read responses will always be delayed by at least one frame.
    
    Param: Table with the following items:
    * pipe
      - Name of the pipe being written, without OS path prefix.
    * cue
      - Callback, optional, the cue to call when the read completes.
    * continuous
      - Bool, optional, if True then this read will continuously run,
        returning messages read but not ending the request.
      - This allows a pipe to be read multiple times in a single frame
        with a single read request (otherwise multiple parallel read
        requests would be needed).
      - Should not be used with timeout.
    * time
      - Timeout, optional, the time until a pending read is cancelled.
      - After a timeout, the pipe will still listen for the message and
        throw it away when it arrives. This behavior can be changed with
        the next arg.
    * cancel_on_timeout
      - Bool, if a timeout event should also cancel all pending
        reads to the pipe (triggers errors for requests other than
        this one).
      - Defaults false.
      
    Returns:
    - Whatever is read from the pipe in event.param to the callback cue.
    - If the read fails on bad pipe, returns 'ERROR'.
    - If the read times out, returns 'TIMEOUT'.
    - If the read is cancelled on game or ui reload, returns 'CANCELLED'.
    
    Usage example, initial read:
    ```xml
      <signal_cue_instantly 
        name="md.Named_Pipes.Read" 
        param="table[
          $pipe = 'mypipe', 
          $cue = Read_Callback, 
          $time = 5s]">
    ```
    
    Usage example, capture response:
    ```xml
      <cue name="Read_Callback" instantiate="true">
        <conditions>
          <event_cue_signalled/>
        </conditions>
        <actions>
          <set_value name="$read_result" exact="event.param"/>
          <do_if value="$read_result == 'ERROR'">
            <stuff to do on pipe error/>
          </do_if>
          <do_elseif value="$read_result == 'CANCELLED'">
            <stuff to do on cancelled request/>
          </do_elseif>
          <do_elseif value="$read_result == 'TIMEOUT'">
            <stuff to do on pipe timeout/>
          </do_elseif>
          <do_else>
            <stuff to do on read success/>
          </do_else>
        </actions>
      </cue>
    ```
  -->
  <cue name="Read" instantiate="true">
    <conditions>
      <event_cue_signalled/>
    </conditions>    
    <actions>
      <!-- Add the command to the param table, and pass it along. -->
      <set_value name="event.param.{'$command'}" exact="'Read'" />
      <signal_cue_instantly cue="Access_Handler" param="event.param"/>
    </actions>
  </cue>

  <!--@doc-cue
    User function to cancel pending reads of a pipe.
    Does nothing if the pipe does not exist.
    Can be used to stop a continuous read.
    
    Param: Name of the pipe being opened.
          
    Usage example:
    ```xml
      <signal_cue_instantly 
        name="md.Named_Pipes.Cancel_Reads" 
        param="'mypipe'">
    ```
  -->
  <cue name="Cancel_Reads" instantiate="true">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <debug_text text="'%s cancelling reads.'.[event.param]"
                  chance="Globals.$DebugChance" filter="general"/>
      <!-- Just need to send down the pipe name. -->
      <signal_cue_instantly cue="Send_Command" param="table[
                 $pipe_name  = event.param,
                 $command    = 'CancelReads',
                 ]" />
    </actions>
  </cue>

  
  <!--@doc-cue
    User function to check if a pipe is connected to a server, making
    the connection if needed.
    
    Note: if a pipe was connected in the past but the server has since closed,
    and no other operations have been attempted in the meantime, this
    function will report the pipe as still connected.
    
    Param: Table with the following items:
    * pipe
      - Name of the pipe being checked, without OS path prefix.
    * cue
      - Callback, the cue to call when the check completes.
      
    Returns:
    - Value is is sent as event.param to the callback cue.
    - Checks receive 'SUCCESS' or 'ERROR'.
    
    Usage example:
    ```xml
      <signal_cue_instantly 
        name="md.Named_Pipes.Write" 
        param="table[
          $pipe='mypipe', 
          $msg='hello', 
          $cue=Write_Callback, 
          $time=5s]">
    ```
  -->
  <cue name="Check" instantiate="true">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <!-- Add the command to the param table, and pass it along. -->
      <set_value name="event.param.{'$command'}" exact="'Check'" />
      <signal_cue_instantly cue="Access_Handler" param="event.param"/>
    </actions>
  </cue>


  <!--@doc-cue
    User function to close a pipe.
    This is passed down to the lua level, where the pipe file is closed and
    all pending accesses killed (return errors).
    Does nothing if the pipe does not exist.
    
    Param: Name of the pipe being opened.
          
    Usage example:
    ```xml
      <signal_cue_instantly 
        name="md.Named_Pipes.Close" 
        param="'mypipe'">
    ```
  -->
  <cue name="Close" instantiate="true">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <debug_text text="'%s closing if open.'.[event.param, $command]"
                  chance="Globals.$DebugChance" filter="general"/>
      <!-- Just need to send down the pipe name. -->
      <signal_cue_instantly cue="Send_Command" param="table[
                 $pipe_name  = event.param,
                 $command    = 'Close',
                 ]" />
    </actions>
  </cue>


  <!-- (TODO: test; Not well tested, so don't @doc this)
    Set the pipe to suppress reads when paused.
    
    Param:
      Name of the pipe affected.
    
    Usage example:
    ```xml
      <signal_cue_instantly 
        name="md.Named_Pipes.Suppress_Paused_Reads" 
        param="'mypipe'">
    ```
  -->
  <cue name="Suppress_Paused_Reads" instantiate="true">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <signal_cue_instantly cue="Send_Command" param="table[
                 $pipe_name  = event.param,
                 $command    = 'SuppressPausedReads',
                 ]" />
    </actions>
  </cue>

  
  <!--
    Set the pipe to no longer suppress reads when paused. 
    
    Param:
      Name of the pipe affected.
    
    Usage example:
    ```xml
      <signal_cue_instantly 
        name="md.Named_Pipes.Suppress_Paused_Reads" 
        param="'mypipe'">
    ```
  -->
  <cue name="Unsuppress_Paused_Reads" instantiate="true">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <signal_cue_instantly cue="Send_Command" param="table[
                 $pipe_name  = event.param,
                 $command    = 'UnsuppressPausedReads',
                 ]" />
    </actions>
  </cue>
  

  <!--@doc-cue
    Start a new pipe access.
    Several other access cues (Read, Write, etc.) redirect to here.
    
    Param:
      Table with the following items:
      * $pipe
        - String, name of the pipe being accessed, without path prefix.
      * $command
        - String, one of ['Read','Write','WriteSpecial','Check'].
      * $msg
        - String, message to send for writes.
        - Unused for non-writes.
      * $cue
        - Cue to call with the result when operation completes.
        - Optional for writes.
      * $time
        - Time, how long to allow for access before cancelling it.
        - A timeout will trigger a 'TIMEOUT' return value to the callback cue.
        - Optional.
        - Defaults to 1000000s (~270 hours), to basically be disabled.
        - Note: timeout kills this access cue, but does not prevent the lua
          from continuing the operation.  The lua op complete signal
          will be ignored, if/when it arrives.  See option below to change
          this behavior.
      * $cancel_on_timeout
        - Bool or int, if a timeout event should also cancel all pending
          accesses to the pipe (either reads or writes).
        - Defaults false.
        - This will trigger error responses on all cancelled accesses
          except for this one that timed out.
        - Intended for use with reads when the timed-out access is not
          expecting any response, eg. was passively reading.
      * $continuous
        - Bool, optional, if True and this is a Read, then this read will
          continuously run, returning messages read but not ending
          the request.
        - Should not be used with timeout.
      
    Returns:
      Value is is sent as event.param to the callback cue.
        Writes and Checks receive 'SUCCESS' or 'ERROR'.
        Reads receive pipe response or 'ERROR' or 'TIMEOUT' or 'CANCELLED'.
  -->
  <cue name="Access_Handler" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    
    <actions>      
      <!-- Parse inputs. Record some stuff for subcues. -->
      <set_value name="$pipe_name"    exact="event.param.$pipe" />
      <set_value name="$command"      exact="event.param.$command" />
      
      <!-- Callback defaults to null. -->
      <do_if value="event.param.$cue?">
        <set_value name="$callback_cue"      exact="event.param.$cue" />
      </do_if>
      <do_else>
        <set_value name="$callback_cue"      exact="null" />
      </do_else>

      <!-- Timeout cancellation defaults to false for now.-->
      <do_if value="event.param.{'$cancel_on_timeout'}?">
        <set_value name="$cancel_on_timeout"      exact="event.param.$cancel_on_timeout" />
      </do_if>
      <do_else>
        <set_value name="$cancel_on_timeout"      exact="false" />
      </do_else>
      
      <!--Continuous mode storage for later check.-->
      <set_value name="$continuous" exact="@event.param.$continuous" />
      

      <!-- Calculate the real time of the timeout, by adding to current age. -->
      <!-- TODO: switch to using realtime api. -->
      <do_if value="event.param.$time?">
        <set_value name="$scheduled_timeout"  exact="player.age + event.param.$time" />
      </do_if>
      <do_else>
        <!--Set something super large; don't want this triggering since 
            it can leave stale requests in the lua fifo.-->
        <set_value name="$scheduled_timeout"  exact="player.age + 1000000s" />
      </do_else>
            
      <!-- Get a new access id to use. Adds $access_id -->
      <include_actions ref="Get_Next_Access_ID"/>

      <!--In continuous mode, reserve the id.-->
      <do_if value="$continuous">
        <set_value name="Globals.$reserved_ids.{'$'+$access_id}" exact="1"/>
      </do_if>
      
      <!--Preconstruct the signal name that lua will use.
          Eg. "pipeRead_complete_123"
          TODO: trim down signal name for fast string compare, and put id first.
      -->
      <set_value name="$lua_signal" exact="'pipe'+ $command +'_complete_'+$access_id"/>

      <!--Send the command.-->
      <signal_cue_instantly cue="Send_Command" param="table[
                 $pipe_name  = $pipe_name,
                 $command    = $command,
                 $access_id  = $access_id,
                 $message    = @event.param.$msg,
                 $continuous = $continuous,
                 ]" />
    </actions>
    
    <cues>
      <!--
        Support function to complete this access.
        Handles the callback, if necessary.
        Cancels other subcues and the parent.
        Uses these variables:
          $callback : cue or null
          $response : string; optional if no callback.
          
        Call with include_actions:
        <include_actions ref="Complete_Access"/>
        
        Note: if this is a continuous read, and the response isn't an
        error (or timeout, but that shouldn't happen), then don't cancel.
      -->
      <library name="Complete_Access">
        <actions>
          <!-- Signal the callback cue with this response. -->
          <do_if value="$callback_cue.exists">
            <signal_cue_instantly cue="$callback_cue" param="$response"/>
          </do_if>
          
          <!--Stop other subcues by cancelling the parent.
              Note: this had trouble with "parent" still leaving subcues
              running, so try "namespace" (which should be the root instance).
              (TODO: revisit this to verify it works correctly, but seems to.)
              
              Skip if continuous read and not an error.
              (Put @ on $continuous to catch older versions that didn't
              have the var.)
          -->
          <do_if value="not @$continuous 
                 or $response == 'ERROR' 
                 or $response == 'CANCELLED' 
                 or $response == 'TIMEOUT'">
            <!--Clear id reservation, if still present. 
                (May not be after a reload.)-->
            <do_if value="@$continuous and Globals.$reserved_ids.{'$'+$access_id}?">
              <remove_value name="Globals.$reserved_ids.{'$'+$access_id}"/>
            </do_if>
            
            <cancel_cue cue="namespace"/>
          </do_if>
        </actions>
      </library>

      
      <!--
        Listen for the lua completion signal, get result.
        Services both reads and writes.
        This should only fire once (don't instantiate), except for 
        continuous reads which will reset it directly.
      -->
      <cue name="Capture_Lua_Response">
        <conditions>
          <event_ui_triggered screen="'Named_Pipes'" control="$lua_signal" />
        </conditions>
        
        <actions>
          <!-- Grab the returned value. -->
          <!-- An ERROR may have been returned. Ignore for now. -->
          <set_value name="$response" exact="event.param3" />

          <!--If continuous, reset self.-->
          <do_if value="$continuous">
            <reset_cue cue="this"/>
          </do_if>
          
          <!-- Debug announcement.  -->
          <debug_text text="'%s %s returned: %s'.[@$pipe_name, @$command, @$response]" chance="Globals.$DebugChance" filter="general"/>
                    
          <!-- Handle the callback. -->
          <include_actions ref="Complete_Access"/>
          
        </actions>        
      </cue>
      
      
      <!--
        Detect if the LUA/pipe interface was reloaded.
        This will cancel out the pending access as an error.
        In case something goes wrong in development, this will be instanced,
        so it can fire again on another reload (eg. after a bug is fixed).
      -->
      <cue name="Reload_Listener" instantiate="true" >
        <conditions>
          <event_cue_signalled cue="Reloaded"/>
        </conditions>
        
        <actions>
          <!-- Debug announcement. -->
          <debug_text text="'%s %s cancelled on reload'.[@$pipe_name, @$command]" chance="Globals.$DebugChance" filter="general"/>
                    
          <!-- Set the return value as CANCELLED. -->
          <set_value name="$response" exact="'CANCELLED'" />
          
          <!-- Handle the callback. -->
          <include_actions ref="Complete_Access"/>          
        </actions>
      </cue>
      
      <!--
        Timeout check.
        $scheduled_timeout should be available prior to setting up this cue.
        
        Uses checktime to handle the timeout condition.
        TODO: switch to a lua realtime timer.
      -->
      <cue name="Access_Timeout" checkinterval="1s" checktime="$scheduled_timeout">
        <conditions>
          <!-- Uncomment to disable this cue.
          <check_value value="false"/> -->
        </conditions>
        <actions>
          <!-- Debug announcement. -->
          <debug_text text="'%s %s timed out'.[@$pipe_name, @$command]" chance="Globals.$DebugChance" filter="general"/>
                    
          <!--If requested, signal the lua to remove queued accesses.
              Note: this will trigger the access to return an error, which
              should be ignored safely if other logic works right. -->
          <do_if value="$cancel_on_timeout">
            <do_if value="$command == 'Write' or $command == 'WriteSpecial'">
              <signal_cue_instantly cue="Send_Command" param="table[
                 $pipe_name  = $pipe_name,
                 $command    = 'CancelWrites',
                 ]" />
            </do_if>
            <do_elseif value="$command == 'Read'">
              <signal_cue_instantly cue="Send_Command" param="table[
                 $pipe_name  = $pipe_name,
                 $command    = 'CancelReads',
                 ]" />
            </do_elseif>
          </do_if>
          
          <!-- Set the return value as TIMEOUT. -->
          <set_value name="$response" exact="'TIMEOUT'" />
          
          <!-- Handle the callback. -->
          <include_actions ref="Complete_Access"/>
          
        </actions>
      </cue>
      
    </cues>
  </cue> <!-- end Access_Handler -->


  <!--
    Small menu plugin for reporting status.
    Makes use of the simple menu api, if available, else throws an error.
    
    TODO: option to enable debug logging (maybe per pipe).
  -->
  <cue name="Register_Options_Menu" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled cue="md.Simple_Menu_API.Reloaded"/>
    </conditions>
    <actions>
      <!-- Register the parent menu. -->
      <signal_cue_instantly
        cue="md.Simple_Menu_API.Register_Options_Menu"
        param = "table[
            $id      = 'named_pipes_menu',
            $columns = 2, 
            $title   = Text.$Named_Pipes_API,
            $onOpen  = Build_Options_Menu
            ]"/>
    </actions>
  </cue>


  <!-- (Don't @doc this, to reduce new user confusion)
    
    Set up a menu line to show the connection status and name of a pipe.
    The input is a cue object holding the display data, and is intended
    for use by the Pipe_Server_Lib.Server_Reader instances.
    
    Param: Top level cue.
    
    The provided cue should have these member variables:
    * Pipe_Name
      - String, name of the OS level pipe.
    * server_connected
      - Bool, true when the pipe is connected to a server.
  -->
  <cue name="Register_Menu_Entry" instantiate="true">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <append_to_list name="Globals.$pipe_status_cues" exact="event.param"/>
    </actions>
  </cue>

  <!--
      Callback for building the options menu.
    -->
  <cue name="Build_Options_Menu" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>

      <!-- Column labels. -->
      <signal_cue_instantly cue="md.Simple_Menu_API.Add_Row"/>
      <signal_cue_instantly
        cue="md.Simple_Menu_API.Make_Text"
        param = "table[
            $col           = 1, 
            $text          = Text.$Pipe, 
            $mouseOverText = Text.$pipe_mouseover,
            $cellBGColor   = 'Helper.color.transparent60',
            ]"/>
      <signal_cue_instantly
        cue="md.Simple_Menu_API.Make_Text"
        param = "table[
            $col           = 2, 
            $text          = Text.$Status, 
            $mouseOverText = Text.$status_mouseover,
            $cellBGColor   = 'Helper.color.transparent60',
            ]"/>
      
      <!-- Loop over registered pipe handler cues. -->
      <do_all exact="Globals.$pipe_status_cues.count" counter="$i">
        
        <!-- Set the text string, connected/disconnected with color. -->
        <do_if value="@Globals.$pipe_status_cues.{$i}.{'$server_connected'}">
          <set_value name="$text" exact="Text.$connected"/>
          <set_value name="$color" exact="'Helper.color.green'"/>
        </do_if>
        <do_else>
          <set_value name="$text" exact="Text.$disconnected"/>
          <set_value name="$color" exact="'Helper.color.red'"/>
        </do_else>
        
        <signal_cue_instantly cue="md.Simple_Menu_API.Add_Row"/>
        <signal_cue_instantly
          cue="md.Simple_Menu_API.Make_Text"
          param = "table[
            $col=1, 
            $text= '' + @Globals.$pipe_status_cues.{$i}.{'$Pipe_Name'},
            $cellBGColor = 'Helper.color.transparent60',
            ]"/>
        <signal_cue_instantly
          cue="md.Simple_Menu_API.Make_Text"
          param = "table[
            $col = 2, 
            $text = $text,
            $color = $color,
            $cellBGColor = 'Helper.color.transparent60',
            ]"/>
      </do_all>
    </actions>
  </cue>

</cues>
</mdscript><?xml version="1.0" encoding="utf-8" ?>
<mdscript name="Pipe_Server_Host" 
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" >

<!-- @doc-title MD Pipe Python Host -->
  
<!-- @doc-overview
MD API for interfacing with an external Python based pipe server.
This allows user MD code to register a python module with the host server.
The host (if running) will dynamically import the custom module.
Such modules are distributed with extensions.
Builds on top of the Named Pipes API.


Goals:
 - Connect to the running python host server process.
 - Allows user to specify the relative path to a python server plugin.
 - Extract the absolute path of x4 and transmit it to the server, for
   the currently running x4 installation (assume multiple on a computer).
 - Transmit user file paths to the host server, to be dynamically imported
   and started.
 - Detect host server errors, and re-announce user files upon
   reconnection.
    
Operation notes:
 - Requires the Python host server be set up and started. This is done by
   the player outside of the game, though can be started before or after
   x4.
 - Pings the server pipe until getting a connection.
 - Failed pings will wait some time before the next ping.
 - Transfers the lua package.paths to the server, where python code parses
   out the x4 absolute path. (Should be adaptable to multiple x4 installations
   without requiring extra player setup.)
 - Reloads on any error, as well as on game or ui reloads.
 - When reloading, signals the Reloaded cue, telling users to register
   their server plugin paths.
 - Passively reads the host server, watching for disconnect errors.
  
Usage:  
 - From MD code, call Register_Module to tell the host to import a
   python module from your extension.   
 - Write the corresponding python server module. This requires a "main"
   function to act as the entry point, and should preferably import
   the Pipe_Server class from X4_Python_Pipe_Server.   
 - Simple python example, echo messages sent from x4 back to it:
    ```python
    from X4_Python_Pipe_Server import Pipe_Server
    def main():
        pipe = Pipe_Server('x4_echo')
        pipe.Connect()
        while 1:
            message = pipe.Read()
            pipe.Write(message)
    ```
    
-->
<cues>

      
  <!-- Use the generic server reader library.
      Needs a cue wrapping it, else get property errors on the library refs. -->
  <cue name="Server_Reader_Wrapper">
    <cues>
      <cue name="Server_Reader" ref="md.Pipe_Server_Lib.Server_Reader">
        <param name="Actions_On_Reload"   value="Actions_On_Reload"/>
        <param name="Actions_On_Connect"  value="Actions_On_Connect"/>
        <param name="Actions_On_Read"     value="Actions_On_Read"/>
      </cue>
    </cues>
  </cue>
  
  
  <library name="Actions_On_Reload">
    <actions>
      <set_value name="$DebugChance" exact="0" />
      <!-- Name of the pipe. -->
      <set_value name="$Pipe_Name" exact="'x4_python_host'" />
      <!-- Empty list of server paths. -->
      <set_value name="$registered_modules" exact="[]"/>      
      <!-- Send a signal that all users listen to. -->
      <signal_cue_instantly cue="md.Pipe_Server_Host.Reloaded"/>
    </actions>
  </library>

  
  <library name="Actions_On_Connect">
    <actions>
      <!--Send the lua side package.path string to the server, 
          containing the path to this x4 installation. -->
      <signal_cue_instantly 
        cue="md.Named_Pipes.Write_Special" 
        param="table[
          $pipe = $Pipe_Name, 
          $msg = 'package.path' ]"/>
      
      <!-- Announce the modules to start up. -->
      <include_actions ref="md.Pipe_Server_Host.Register_Modules_With_Server"/>                    
    </actions>
  </library>
  
  
  <library name="Actions_On_Read">
    <actions>
      <!-- Nothing expected for now. -->
      <debug_text text="'received mesage: %s.'.[event.param]" 
                  chance="$DebugChance" filter="general"/>
    </actions>
  </library>
  
  
  <!--
    Dummy cue used for signalling.
    When the api wants users to register their servers, it will signal
    this cue. Users can then listen to this cue being signalled.
    This is also used to kill off an older server access loop.
  -->  
  <cue name="Reloaded" instantiate="true">
    <conditions>
      <event_cue_signalled />
    </conditions>
    <actions>
    </actions>
  </cue>
    
  
  <!-- @doc-cue
    User function to register a python server module.
    This should be resent each time Reloaded is signalled.
    
    Param:
      String, relative path to the python file from the x4 base dir.
      Use forward slashes between folders.
    
    Usage example:
    ```xml
      <cue name="Register_Pipe_Server" instantiate="true">
        <conditions>
          <event_cue_signalled cue="md.Pipe_Server_Host.Reloaded" />
        </conditions>
        <actions>
          <signal_cue_instantly 
            cue="md.Pipe_Server_Host.Register_Module" 
            param="'extensions/sn_hotkey_api/Send_Keys.py'"/>
        </actions>
      </cue>
    ```
  -->
  <cue name="Register_Module" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    
    <actions>
      <set_value name="$path" exact="event.param"/>
      
      <!-- Check if this path is not yet known. -->
      <do_if value="Server_Reader.$registered_modules.indexof.{$path} == 0">
        <!-- Add to the list. -->
        <append_to_list name="Server_Reader.$registered_modules" exact="$path" />
        <debug_text text="'registered server path: %s.'.[$path]" 
                    chance="Server_Reader.$DebugChance" filter="general"/>
        
        <!-- Update the server. If it isn't connected, ignore any error. -->
        <include_actions ref="Register_Modules_With_Server"/>
        
        <!-- Make sure the read loop is started, if it wasn't already. -->
        <signal_cue cue="Server_Reader.$Start_Reading" />
        
      </do_if>
    </actions>    
  </cue>
        
    
  <!-- Lib function to update the server list of registered modules. -->
  <library name="Register_Modules_With_Server">
    <actions>
      <!-- Suppress if not connected to server, to reduce log spam. -->
      <do_if value="Server_Reader.$server_connected == 1">
      
        <!-- Start by merging the entries together, semicolon separated. -->
        <set_value name="$joined_modules" exact="''" />
        <do_all exact="Server_Reader.$registered_modules.count" counter="$i">
          <set_value 
            name="$joined_modules" 
            exact="$joined_modules + Server_Reader.$registered_modules.{$i} + ';'"/>
        </do_all>
        
        <!-- Send this to the server. -->
        <signal_cue_instantly 
          cue="md.Named_Pipes.Write" 
          param="table[
            $pipe = Server_Reader.$Pipe_Name, 
            $msg = 'modules:'+$joined_modules ]"/>
        
      </do_if>
    </actions>
  </library>
  
  
</cues>

</mdscript><?xml version="1.0" encoding="utf-8" ?>
<mdscript name="Pipe_Server_Lib" 
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" >

<!-- @doc-title MD Pipe Connection Helper -->
  
<!--
Library of functions to aid in writing MD interfaces to external servers.

Currently just supports passively reading a pipe.
    
Notes on server access looping cues:

  The cues for accessing the server, either pinging or reading, form
  oscillating loops.  A ping that fails in the callback will re-ping,
  and a read that succeeds or times out will re-read (for the next message).
  Stopping oscillating loops upon reset (game or ui reload) is non-trivial
  to do in a robust, bug-resistant way.
  
  If the cues are made static, they require reset_cue to reuse.  However, this
  command appears to only take effect at the end of a game frame, and hence
  all attempts to re-call a cue that was reset earlier in the same frame
  will fail.  Same-frame recall is a common case, so all experiments with
  resetting static cues were dead ends.
  
  If the cues are instantiated, they can be recalled in the same frame, but
  there is a danger of multiple instances being active, which is not
  wanted.  While the general design of this api would try to avoid such
  multi-instance problems, bugs are always possible.
  
  The current design packs all oscillating cues in a parent Server_Access_Loop
  cue.  When signalled, this cue will record its instance into a global
  variable, and a condition will prevent a new instance starting if the
  prior one is still active.  Internally, a conditionless cue is used to
  start the pinging loop.  When the api reloads (such as on a pipe disconnect
  event), an internal cue will cancel the instance of Server_Access_Loop,
  such that a new instance can be started.
-->
<cues>


  <!--@doc-cue
    Library package of cues used to simplify handling server connections
    by supporting the following behaviors:
    * Ping server until succesfully connecting,
    * Listen for server messages,
    * Detect disconnections and recover.
    
    Note: the parameters of this library will all be references to other
    libraries containing action blocks to execute here.  Such action blocks
    will use the namespace of the Server_Reader instance, and their
    scope for md cue lookups will be from the Pipe_Server_Lib file.
        
    Parameters:
    * Actions_On_Reload
      - Library of actions to perform when reloading after a pipe
        disconnect, savegame reload, ui reload, as well as initial creation.
      - Should set attributes: Pipe_Name, and optionally DebugChance.
      - May add other variables to the library instance, if desired.
    * Actions_On_Connect
      - Optional library of actions to perform upon connecting to the server.
      - May signal $Start_Reading to begin passive reading of the pipe.
    * Actions_On_Read
      - Optional library of actions to perform when reading a message from 
        the server.
      - The message will be in event.param.
      
    Attributes (write these in Actions_On_Reload):
    * $Pipe_Name
      - Name of the pipe used to communicate with the python host.
    * $DebugChance
      - Optional, 0 or 100.
      
    Interface variables:
    * $Start_Reading
      - Internal cue, made available as a variable.
      - Must be signalled to start the server connection routine.
      - If the connection is ever broken, which will occur on a Reload
        or possibly through param actions, this needs to be signalled
        again to reconnect.
      - Note: this is only available 2 frames after the Server_Reader
        cue is set up (as opposed to 1 frame delay for other attributes).
  
    Local variables:
    * $server_access_loop_cue
      - Cue or null, the currently active Server_Access_Loop cue instance.
      - Starts as null. If an active instance dies, the "exists" property
        will return false.
    * $server_connected
      - Flag, 1 when the server has been pinged succesfully and appears to
        have a valid connection. 0 before connection is set up, or after
        an error/disconnect. Used to suppress some writes before a
        connection is made, though shouldn't be critical to functionality.
    * $ping_count
      - Int, how many failed pings have occurred.
      - Used to increase ping delay after failures.
      - Not an exactly count; only goes up to the highest delay, eg. 10.
        
    Note: 
      x4 has problems when a cue using this library is created alongside
      the action-libraries to be given as parameters.  While other cues can
      be passed in this way, libraries cannot.      
      As a workaround, a dummy cue can be wrapped around the cue
      that refs this library.
      
    Example usage:
    ```xml
      <cue name="Server_Reader_Wrapper">
        <cues>
          <cue name="Server_Reader" ref="md.Pipe_Server_Lib.Server_Reader">
            <param name="Actions_On_Reload"   value="Actions_On_Reload"/>
            <param name="Actions_On_Connect"  value="Actions_On_Connect"/>
            <param name="Actions_On_Read"     value="Actions_On_Read"/>
          </cue>
        </cues>
      </cue>
      
      <library name="Actions_On_Reload">
        <actions>
          <set_value name="$Pipe_Name" exact="'my_x4_pipe'" />
        </actions>
      </library>
      
      <library name="Actions_On_Connect">
        <actions>
          <signal_cue cue="$Start_Reading" />
        </actions>
      </library>
      
      <library name="Actions_On_Read">
        <actions>
          <debug_text text="'received mesage: %s.'.[event.param]"
                    chance="$DebugChance" filter="general"/>
        </actions>
      </library>

        ```
        -->
  <library name="Server_Reader">
    <params>
      <param name="Actions_On_Init"    default="null"/>
      <param name="Actions_On_Reload"  default="null"/>
      <param name="Actions_On_Connect" default="null"/>
      <param name="Actions_On_Read"    default="null"/>
    </params>

    <actions>
      <!--Start with a dummy pipe name for first-run; this should get overwritten.-->
      <set_value name="$Pipe_Name" exact="'temp'"/>
      <!-- Initial global var setup; done incase user code immediately checks 
            stuff like server_connected before Reset_On_Lua_Reload fires. -->
      <include_actions ref="Reset_Globals"/>
    </actions>
  
    <cues>
    
      <!-- Delayed setup that references cues. -->
      <cue name="Delayed_Init">
        <actions>
          <!-- Set a link to the Server_Access_Loop cue, visible externally. -->
          <set_value name="$Start_Reading" exact="Server_Access_Loop"/>
          <!-- TODO: Stop_Reading, Reset, Disconnect, or similar style commands. -->
        </actions>
      </cue>
      
      <!-- Reused setup of global vars. -->
      <library name="Reset_Globals">
        <actions>
          <!-- Note: don't make a default pipe name; let it error if user forgets. -->
          <set_value name="$DebugChance" exact="0"/>
          <!-- Assume no access loop active; any old one should self-kill. -->
          <set_value name="$server_access_loop_cue" exact="null"/>
          <!-- Server is never connected at reset. -->
          <set_value name="$server_connected" exact="0"/>
          <!-- Clear failed ping count. -->
          <set_value name="$ping_count" exact="0"/>
        </actions>
      </library>

      
      <!-- Register a menu entry. -->
      <cue name="Register_Menu_Entry" instantiate="true">
        <conditions>
          <check_any>
            <event_cue_signalled cue="md.Named_Pipes.Reloaded" />
          </check_any>
        </conditions>
        <actions>
          <signal_cue_instantly cue="md.Named_Pipes.Register_Menu_Entry"
                                param="this.parent" />
        </actions>
      </cue>

      <!--
        Handle game creation, reload, or ui reload, as well as server pipe
        disconnection.
        In practice, this is best handled by listening to a signal from
        the named pipe api, to ensure that has reloaded first.
      -->
      <cue name="Reset_On_Lua_Reload" instantiate="true">
        <conditions>
          <check_any>
            <event_cue_signalled/>
            <event_cue_signalled cue="md.Named_Pipes.Reloaded" />
            <event_ui_triggered screen="'Named_Pipes'" 
                                control="'%s_disconnected'.[$Pipe_Name]" />
          </check_any>
        </conditions>
        <actions>
          <!--<debug_text text="'Reloading'" chance="100" filter="general"/>-->
          <!-- Make sure the global vars are reset. -->
          <include_actions ref="Reset_Globals"/>
          
          <!-- Run any user supplied actions. -->
          <do_if value="$Actions_On_Reload.exists">
            <include_actions ref="$Actions_On_Reload"/>
          </do_if>
          
          <debug_text text="'reload triggered.'" 
                      chance="$DebugChance" filter="general"/>
          
          <!--Send a signal that all users listen to. 
              Do this instantly; don't want it getting delayed until after
              Server_Access_Loops are started.
              TODO: maybe do this before user actions. -->
          <signal_cue_instantly cue="Reloaded"/>
          
        </actions>
      </cue>
      
      
      <!--
        Dummy cue used for local signalling.
      -->  
      <cue name="Reloaded" instantiate="true">
        <conditions>
          <event_cue_signalled />
        </conditions>
        <actions>
        </actions>
      </cue>
             
      
      <!--
        Parent cue for the subcues that access a server, pinging and reading.
        Subcues will form oscillating loops.
        This will cancel its instance when a reload occurs.
        This will not start if a prior instance still exists, as stored
        in $server_access_loop_cue.
        Instanced, so this can be cancelled and recalled in the same frame.
      -->
      <cue name="Server_Access_Loop" instantiate="true">
        <conditions>
          <event_cue_signalled/>
          <check_value value="not $server_access_loop_cue.exists"/>
        </conditions>
        <actions>
          <set_value name="$server_access_loop_cue" exact="this"/>
          <debug_text text="'Starting server access loop for ' + $Pipe_Name"
                      chance="$DebugChance" filter="general"/>
        </actions>
        
        <cues>
        
          <!-- Dummy cue, no conditions, calls Ping_Server right away. -->
          <cue name="Init_Ping_Server">
            <actions>
              <debug_text text="'Init_Ping_Server triggered for ' + $Pipe_Name"
                          chance="$DebugChance" filter="general"/>
              <signal_cue_instantly cue="Ping_Server"/>
            </actions>        
          </cue>
          
          
          <!-- 
            Detect a reload, and kill this access loop instance.
            Since this is not instantiated, it will keep the Server_Access_Loop
            alive until this fires.
          -->
          <cue name="Reload_Listener">
            <conditions>
              <event_cue_signalled cue="Reloaded" />
            </conditions>
            <actions>
              <debug_text text="'Reload_Listener triggered for ' + $Pipe_Name"
                          chance="$DebugChance" filter="general"/>
              <!-- Do not reset flags; they are handled by generic reload code. -->
              <cancel_cue cue="parent"/>
            </actions>        
          </cue>
      
          
          <!-- 
            Lib function for cancelling the parent cue and resetting some state.
            Use this to end the Server_Access_Loop when no modules are registered.
          -->
          <library name="Cancel_Server_Access_Loop">
            <actions>
              <!--Cancel any pending read request.-->
              <signal_cue_instantly 
                cue="md.Named_Pipes.Cancel_Reads" 
                param="table[$pipe=$Pipe_Name]"/>
              
              <!-- Clear any necessary flags. -->
              <set_value name="$server_connected" exact="0"/>
              
              <!-- Cancel the namespace, which is the instanced parent 
                  (not the static parent). -->
              <cancel_cue cue="namespace"/>
            </actions>
          </library>
          
      
          <!-- Ping the server to see if it is available. -->
          <cue name="Ping_Server" instantiate="true">
            <conditions>
              <event_cue_signalled/>
            </conditions>
            <actions>
              <debug_text text="'Pinging ' + $Pipe_Name"
                          chance="$DebugChance" filter="general"/>
              <signal_cue_instantly 
                cue="md.Named_Pipes.Write" 
                param="table[$pipe=$Pipe_Name, $msg='ping', $cue=Ping_Callback]"/>
            </actions>
          </cue>
          
          
          <!-- Check if ping write went through. -->
          <cue name="Ping_Callback" instantiate="true">
            <conditions>
              <event_cue_signalled/>
            </conditions>
            <actions>      
            
              <!-- 
                If an error then the server isn't set up, so wait to ping again.
                Note: if the server was never connected to, lua will not send
                a disconnect signal, and so the Reloaded cue will not have
                been activated.
              -->
              <do_if value="event.param == 'ERROR'">
                <!--
                  Restart pinging routine, after some delay.
                  First pings gets shorter delay; further failures get longer
                  delay.  Cap ping counting at 10 for now.
                -->
                <do_if value="$ping_count le 10">
                  <set_value name="$ping_count" operation="add"/>
                </do_if>
                <signal_cue_instantly cue="Ping_Server_After_Delay"/>
                <!--TODO: maybe a way to check if loop should stop, 
                    with a flag or user actions.-->
              </do_if>
              
              <!-- On a game reload, this comes back as cancelled; don't loop. -->
              <do_elseif value="event.param == 'CANCELLED'">
                <!-- The parent cue is getting killed by other logic, so do nothing. -->
              </do_elseif>
              
              <do_else>
                <!-- Connected; continue with startup. -->
                <set_value name="$server_connected" exact="1"/>
                <!-- Reset the ping counter. TODO: maybe unnecessary. -->
                <set_value name="$ping_count" exact="0"/>

                <debug_text text="'Connected to ' + $Pipe_Name"
                            chance="$DebugChance" filter="general"/>

                <!-- Run any user supplied actions. -->
                <do_if value="$Actions_On_Connect.exists">
                  <include_actions ref="$Actions_On_Connect"/>
                </do_if>
                
                <!-- Can kick off a first read right away. -->
                <signal_cue_instantly cue="Read_Message"/>
              </do_else>
            </actions>
          </cue>
          
          
          <!--
            Trigger ping after various delays.
            Should be used by the ping loop to reduce ping overhead.
            This will wait ($ping_count - 0.75) seconds. Adjustment allows
            pipes to do a quick reconnect check after the host connects.
            Uses the Time api to time this using realtime, so it works
            while the game is paused.
            
            This will not instantiate. For safety, it only allows one pending
            ping at a time, and resets self.
          -->
          <cue name="Ping_Server_After_Delay">
            <conditions>
              <event_cue_signalled/>
            </conditions>
            <actions>
              <!--TODO: maybe make sure no colons are in the pipe name.-->
              <set_value name="$ping_name" exact="'%1:%2'.[$Pipe_Name, $ping_count - 0.75]"/>
              <!--Set an alarm-->
              <raise_lua_event name="'Time.setAlarm'"  param="$ping_name"/>
            </actions>
            <cues>
              <cue name="Wait_For_Alarm">
                <conditions>
                  <!-- Wait for the alarm to go off. -->
                  <event_ui_triggered screen="'Time'" control="$Pipe_Name" />
                </conditions>
                <actions>
                  <!--Trigger another ping.-->
                  <signal_cue_instantly cue="Ping_Server"/>
                  <!--Reset parent.-->
                  <reset_cue cue="parent"/>
                </actions>
              </cue>              
            </cues>
          </cue>
          
              
            
          <!--Send a read request, wait for timeout or error or message.
              Used to detect when the server host disconnects.
              
              TODO: maybe a lua level option to reduce how often the pipe 
              reads are attempted; every frame is probably unnecessary 
              (though perhaps has no noticeable overhead).
              
              This will be set to continuous read mode, so multiple messages
              can be read per frame.
          -->
          <cue name="Read_Message" instantiate="true">
            <conditions>
              <event_cue_signalled/>
            </conditions>
            <actions>
              <signal_cue_instantly 
                cue="md.Named_Pipes.Read" 
                param="table[$pipe=$Pipe_Name, $cue=Read_Callback, $continuous=true]"/>
            </actions>
          </cue>
          
          
          <!--Handle the read message.
              On error, resets.
              On timeout, loops to another read.
              Currently not expecting control messages, but they may be added
              in the future.
              
              Note: this will be at least 1 frame after Read_Message.
              
              Note: the lua api will raise a disconnect signal if it sees the
              host server disconnect, which triggers Reloaded and hence cancels
              this Server_Access_Loop.  On a game reload, the lua is reset and
              cannot send this signal, but Reloaded triggers anyway in this
              case, again killing this cue.
              As such, this cue doesn't need to handle errors,
              but will be set up to do so for redundancy in case of bugs.
          -->
          <cue name="Read_Callback" instantiate="true">
            <conditions>
              <event_cue_signalled/>
            </conditions>
            
            <actions>
            
              <!-- If error, assume the server shut down. -->
              <do_if value="event.param == 'ERROR'">
                
                <!--Lua should have signalled the disconnect, killing this 
                    cue by other logic, but be safe here. -->                
                <!-- Note that the pipe disconnected. -->
                <set_value name="$server_connected" exact="0"/>
                
                <!-- Restart pinging routine. -->
                <signal_cue_instantly cue="Ping_Server"/>
                <debug_text text="'pipe error; restarting Ping_Server for '+$Pipe_Name" 
                            chance="$DebugChance" filter="general"/>            
              </do_if>
              
              <!-- On a game reload, this comes back as cancelled; don't loop. -->
              <do_elseif value="event.param == 'CANCELLED'">
                <!-- The parent cue is getting killed by other logic, so do nothing. -->
              </do_elseif>
              
              <!-- On timeout, try another read. 
                  -Removed, timeouts not in use.
              <do_elseif value="event.param == 'TIMEOUT'">
                <signal_cue_instantly cue="Read_Message"/>        
              </do_elseif> -->
                    
              <do_else>
                <!-- Read succeeded with some message. -->
                
                <!-- Run any user supplied actions. -->
                <do_if value="$Actions_On_Read.exists">
                  <include_actions ref="$Actions_On_Read"/>
                </do_if>
                
                <!-- Request the next key to be read, looping. 
                    -Removed, using continuos reads.
                <signal_cue_instantly cue="Read_Message"/> -->
              </do_else>    
            </actions>
          </cue>
          
        </cues>
      </cue> <!-- end Server_Access_Loop -->
      
    </cues>
  </library>
  
</cues>

</mdscript><?xml version="1.0" encoding="utf-8" ?>
<mdscript name="Simple_Menu_API" 
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" >
  <!--Note: keep the MD name convenient for users.-->

<!--@doc-title Simple Menu API -->
<!--@doc-overview
MD api for interfacing with a simple lua menu.
The menu will support a 2d table of labels, buttons, and text fields.
On player interaction, the lua will inform this api, which will in turn
activate callback cues provided by the api user.

After creation, widgets may be partially updated at any time. This is
detailed in the Update_Widget cue.    

Note: raise_lua_event only supports passing strings, numbers, or components.
This api will pass complex tables of args using a blackboard var:
  player.entity.$simple_menu_args
  
-->
  
  
<!--@doc-section
### Widget arguments and properties overview
    
Many of the following cues share some common arguments or arg data types, 
described here. Note: many of these can be replaced with a constant looked
up in the egosoft api backend Helper module. Possible options are included
at the end of this documentation.
    
API args (all widgets, partially for rows and menus)
  * col
    - Integer, column of the row to place the widget in.
    - Uses 1-based indexing.
    - Note: row columns may not always align with table columns:
      - This actually sets the widget as the Nth cell of the row,
      - Row column alignment with the table columns depends on the sizes of
        all prior row cells (as possibly adjusted by colSpan).
      - Eg. if the widget in col=1 had a colSpan=2, then a new col=2
        widget will align with table column 3.
    - Required for now.
  * colSpan = 1
    - Int, how many columns the widget will span.
  * id = none
    - String, unique identifier for the widget.
    - Optional, but needed for Update_Widget calls.
  * echo = none
    - Optional, May be any data type.
    - This is returned in the table sent to signalled callback cues,
      for user convenience.
    
Widget properties (all widgets)
  * scaling = true
    - Bool, coordinates and dimensions will be scaled by the ui scaling factor.
  * width, height = 0
    - Ints, widget dimension overrides.
  * x, y = 0
    - Ints, placement offsets.
  * mouseOverText = ""
    - String, text to display on mouseover.
        
Cell properties (all widgets)
  * cellBGColor = 'Helper.defaultSimpleBackgroundColor'
    - Color, cell background color.
  * uiTriggerID = none
    - String, if present then this is the control field for ui
      triggered events on widget activations.
    - Ignore for now; api handles callback cues directly.
        
Events (depends on widget)
  * on<___> (onClick, onTextChanged, etc.)
    - Optional callback cue.
    - When the player interacts with most widgets, ui events will occur.
      On such events, a provided cue will be called with the event results.
    - Most event.param tables will include these fields:
      * row, col
        - Longfloat, coordinate of the activated widget.
        - Primarily for use by this backend.
      * id
        - String id given to the widget at creation, or null.
      * event
        - String, name of the event, matching the arg name.
        - Eg. "onClick".
      * echo
        - Same as the "echo" arg provided to widget creation.
    - Extra contents of the event.param are described per widget below.
        
Misc properties (depends on widget):
  * font
    - String, font to use.
    - Typical options: 
      - "Zekton"
      - "Zekton bold"
      - "Zekton fixed"
      - "Zekton bold fixed"
      - "Zekton outlined"
      - "Zekton bold outlined"
  * fontsize
    - Int, typically in the 9 to 12 range.
  * halign
    - String, text alignment, one of ["left", "center", "right"].
  * minRowHeight
    - Int, minimal row height, including y offset.
        
Complex properties:
  * Color
    - Table of ["r", "g", "b", "a"] integer values in the 0-255 range.
  * TextProperty
    - Table describing a text field.
    - Note: in some widgets "text" is a string, others "text" is
      a TextProperty table.
    - Fields:
      * text = ""
      * halign = 'Helper.standardHalignment'
      * x = 0
      * y = 0
      * color = 'Helper.standardColor'
      * font = 'Helper.standardFont'
      * fontsize = 'Helper.standardFontSize'
      * scaling = true
  * IconProperty
    - Table describing an icon.
    - Fields:
      * icon = ""
        - Icon name
        - See libraries/icons.xml for options.
      * swapicon = ""
      * width = 0
      * height = 0
      * x = 0
      * y = 0
      * color = 'Helper.standardColor'
      * scaling = true
  * HotkeyProperty
    - Table describing an activation hotkey.
    - See libraries/contexts.xml for potential options.
    - Note: hotkeys have not yet worked in testing.
    - Fields:
      * hotkey = ""
        - String, the hotkey action, matching a valid INPUT_STATE.
      * displayIcon = false
        - Bool, if the widget displays the associated icon as a hotkey.
      * x = 0
      * y = 0
        - Offsets of the icon if displayIcon is true.
  * StandardButtonProperty
    - Table specifying which menu level buttons to include.
    - Fields:
      * close = true
      * back = true
      * minimize = false
-->


<cues>

  <!-- Register the main lua file. -->
  <cue name="Load_Lua_Files" instantiate="true">
    <conditions>
      <event_ui_triggered screen="'Lua_Loader'" control="'Ready'" />
    </conditions>
    <actions>
      <raise_lua_event name="'Lua_Loader.Load'"
                       param="'extensions.sn_mod_support_apis.lua_simple_menu_interface'"/>
    </actions>
  </cue>

  <!--
    Static cue that holds some shared state information or constants.
    When this script is installed, a new instance of this cue is created,
    and will afterwards be live until the script is removed.
    Globals reset each time the game is loaded, to enable easy changing
    of constants.
    
    Attributes:
    * options_submenu_specs
      - Table holding specifications for options submenus, accessible through
        the normal options menu.
      - Key is the registered submenu id.
      - Values are tables described in Register_Options_Menu.
    * current, next
      - Ints, 1 or 2, indexes into the next few lists to select entry
        associated with the current or next menu.
      - At init, both == 1.
      - When a menu is being created, 'next' will increment and all new
        properties recorded to next.
      - When callbacks occur, 'current' is used.
      - When lua confirms it is opening the menu (might be delayed from md
        sending command), 'current' will increment to catch up to the most
        recent 'next'.
      - The motivation for this is cases where one custom menu is opened
        over top of another, and the old one will still need its data
        available to handle final callbacks (notably onCloseElement).
      - TODO: think if there is a cleaner way to do this.
    * row
      - Two entry list (for current/next), with following contents per entry:
      - Int, the index of the latest added row.
      - Starts at 1 for the first row.
      - Only considers user rows, not those implicit in the menu (eg. title).
    * menu_properties
      - Two entry list, with following contents per entry:
      - Table holding the menu creation args of the current menu.
    * widget_properties
      - Two entry list, with following contents per entry:
      - Table of tables of properties provided by the user for widgets, 
        annotated with additional information (eg. row number).
      - Holds shallow copies of the user args tables.
      - Outer table keyed by widget row, inner table by widget column.
      - Outer table may also be keyed by widget id, when the user provides
        an id string; in such cases the widget properties table will be
        recorded twice (by id and row/col).
      - Locally used for the callback cue storage, with echoing behavior
        intended to aid the user in handling callbacks.
    * row_properties
      - Two entry list, with following contents per entry:
      - List holding the properties for each row, in order.
      
    Additionally, complex data will be sent to lua using a blackboard var:
    * player.entity.$simple_menu_args
      - List of tables (or none), args sent with lua commands.
      - The list is appended to here, copied and deleted in lua.
      - The list is used to account for (common) cases where multiple commands
        are sent in the same frame, since the lua will only process them late
        in the frame, requiring arg buffering.
      - Since lua cannot edit the list directly, and cannot replace it with
        a modified list, it will just delete this var after reading it.
  -->
  <cue name="Globals">
    <!-- When first created, set up globals. -->
    <actions>
      <include_actions ref="Reset_Globals"/>
    </actions>
    <cues>
      <!--
        Reset when the lua reloads.
        This is mostly aimed at helping with development/debug.
      -->
      <cue name="Reset_On_Lua_Reload" instantiate="true">
        <conditions>
          <event_ui_triggered screen="'Simple_Menu'" control="'reloaded'" />
        </conditions>
        <actions>
          <!--<debug_text text="'Reloading'" chance="100" filter="general"/>-->
          <include_actions ref="Reset_Globals"/>
          <!-- Send a signal that all users listen to. -->
          <signal_cue_instantly cue="Reloaded"/>
        </actions>
      </cue>
    </cues>
  </cue>

  <!-- TODO: can this lib be put into the cues list above? -->
  <library name="Reset_Globals">
    <actions>
      <!-- Debug printout chance; generally 0 or 100; ego style naming. -->
      <!-- Note: Simple_Menu_Options can/will overwrite this. -->
      <set_value name="Globals.$DebugChance" exact="0" />
      <set_value name="Globals.$current" exact="1" />
      <set_value name="Globals.$next"    exact="1" />
      <set_value name="Globals.$options_submenu_specs" exact="table[]" />
      <!-- The following are lists with two entries, initialized with dummies. -->
      <set_value name="Globals.$widget_properties"    exact="[null, null]" />
      <set_value name="Globals.$row_properties"       exact="[null, null]" />
      <set_value name="Globals.$row"                  exact="[null, null]" />
      <set_value name="Globals.$menu_properties"      exact="[null, null]" />
    </actions>
  </library>

  
  <!--@doc-cue
    Dummy cue used for signalling that the game or ui was reloaded.
    Users that are registering options menus should listen to this
    cue being signalled.
  -->  
  <cue name="Reloaded" instantiate="true">
    <conditions>
      <event_cue_signalled />
    </conditions>
    <actions>
    </actions>
  </cue>

  <!-- 
    Small helper function which will replace $args with an empty
    table if it is null.
    -->
  <library name="Init_Args_Table">
    <actions>
      <!-- Make a table if one wasn't given. -->
      <do_if value="$args == null">
        <set_value name="$args" exact="table[]"/>
      </do_if>
    </actions>
  </library>
  
  <!-- 
    Lib helper for fill in default widget args.
    The args table should be in $args.
    Will automatically include a check for null args and init the table,
    so a call to Init_Args_Table isn't needed.
    TODO: remove cloning; Send_Command will do that.
  -->
  <library name="Fill_Widget_Default_Args">
    <actions>
      <include_actions ref="Init_Args_Table"/>
      <!-- Currently just set col to 1 by default. -->
      <do_if value="not $args.$col?">
        <set_value name="$args.$col" exact="1" />
      </do_if>
    </actions>
  </library>
  
  
  <!-- ################################################################### -->
  <!--                             Widgets                                 -->
  <!-- ################################################################### -->
  
  <!--@doc-section
    #### Generic Command Cue
    -->
  
  <!-- Note: assume any users may call Send_Command directly, so do all special
  command handling here. -->
  <!--@doc-cue
    Generic cue for sending commands to lua. Other api cues redirect here
    to interface with the lua backend. Users may utilize this cue if they
    find it more convenient. See other cues for arg descriptions.
    
    Param: Table with the following items:
    * command
      - String, the command to send.
      - Supported commands:
        - Register_Options_Menu
        - Create_Menu
        - Close_Menu
        - Add_Submenu_Link
        - Add_Row
        - Make_Widget
        - Update_Widget
    * ...
      - Any args requied for the command.
      - Note: Make_Widget commands require a $type string to specify the
        widget type (found quoted in per-widget descriptions).
    -->
  <cue name="Send_Command" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <!-- If the param is null, something went wrong in the call. TODO -->
      
      <!-- 
        Use a shallow copy for this, to avoid errors if the user reuses tables.
        This may be needed even if user reuses the table to make the same 
        widget on next menu opening, since this code might get confused
        by eg. auto $row inclusion below.
      -->
      <set_value name="$args" exact="event.param.clone" />
            
      <!-- The following command handlers are ordered most to least common. -->
      
      <!-- Handle widget arg recording. -->
      <do_if value="$args.$command == 'Make_Widget'">
        <!-- TODO: verify a $type was provided. -->
        
        <!-- Store the row in the args, for possible later lookup. -->
        <!-- TODO: support rows being specified ahead of time. -->
        <set_value name="$args.$row" exact="Globals.$row.{Globals.$next}" />
        
        <!-- Set any widget default args. Just col for now. -->
        <do_if value="not $args.$col?">
          <set_value name="$args.$col" exact="1" />
        </do_if>
        
        <!-- The row already has a prepared subtable, so just fill the col. -->
        <set_value name="Globals.$widget_properties.{Globals.$next}.{Globals.$row.{Globals.$next}}.{$args.$col}" exact="$args" />
        <debug_text text="'Recorded args for row,col: (%s,%s)'.[Globals.$row.{Globals.$next}, $args.$col]"
                  chance="Globals.$DebugChance" filter="general"/>
        
        <!-- Also record by user id, if available. -->
        <do_if value="$args.$id?">
          <set_value name="Globals.$widget_properties.{Globals.$next}.{'$'+ $args.$id}" exact="$args" />
        </do_if>
      </do_if>
            
      <!-- Inc row counter. -->
      <do_elseif value="$args.$command == 'Add_Row'">
        <!-- 
          Update the row count, and expand the callback table.
          Note: since the global $row inits to 0, increment will go first to
          bring the first row up to 1 (1-based indexing).
          -->
        <set_value name="Globals.$row.{Globals.$next}" operation="add" />
        <set_value name="Globals.$widget_properties.{Globals.$next}.{Globals.$row.{Globals.$next}}" exact="table[]" />
        
        <!-- Store the properties for later lookup. -->
        <append_to_list name="Globals.$row_properties.{Globals.$next}" exact="$args"/>
      </do_elseif>      
           
      <!-- Handle standalone menu arg recording. TODO: merge in with options menus table. -->
      <do_elseif value="$args.$command == 'Create_Menu'">
        <!-- Inc 'next' with rollover, to point it at the menu data to overwrite. -->
        <set_value name="Globals.$next" exact="if (Globals.$next == 1) then 2 else 1"/>
          
        <!-- Setup fresh globals. -->
        <set_value name="Globals.$widget_properties.{Globals.$next}" exact="table[]" />
        <set_value name="Globals.$row_properties.{Globals.$next}" exact="[]" />
        <set_value name="Globals.$row.{Globals.$next}" exact="0" />
        <set_value name="Globals.$menu_properties.{Globals.$next}" exact="$args"/>
      </do_elseif>
            
      <!-- Handle options menu arg recording. -->
      <do_elseif value="$args.$command == 'Register_Options_Menu'">
        <!-- Record the args using the menu id, $ prefixed. -->
        <set_value name="Globals.$options_submenu_specs.{'$'+event.param.$id}" exact="$args" />
      </do_elseif>      
      
      <!-- Args are transmitted to lua using a blackboard var. -->
      <!-- Create the blackboard list if it doesn't exist. -->
      <do_if value="not player.entity.$simple_menu_args?">
        <set_value name="player.entity.$simple_menu_args" exact="[]" />
      </do_if>
      <append_to_list name="player.entity.$simple_menu_args" exact="$args"/>

      <debug_text text="'Sending Process_Command with args: %s'.[$args]"
                chance="Globals.$DebugChance" filter="general"/>

      <!-- Signal the lua function. -->
      <raise_lua_event name="'Simple_Menu.Process_Command'"/>
    </actions>
  </cue>

  
  
  <!-- ################################################################### -->
  <!--                            Menu Setup                               -->
  <!-- ################################################################### -->
  
  <!--@doc-section
    #### Menu Creation Cues
    -->
  
  <!--TODO: frame+table general properties.-->
  <!--TODO: ways to change some defaults, notable text.-->
  <!--@doc-cue
    Create a fresh standalone menu.
    Note: these menus are not attached to the normal options menu.
    To be followed by Add_Row and similar cue calls to fill in the menu.
    
    Each menu created will internally be given a frame to hold a table
    in which widgets will be placed.  The frame and table properties
    are also set with this cue.
    
    Param: Table with the following items:
    * id, echo
      - Standard api args
    * columns
      - Integer, total number of columns in the menu table.
      - Max is 13 (as of x4 4.0).
    * title
      - Text to display in the table header.
    * width
      - Int, optional, menu width. Defaults to a predefined width.
    * height
      - Int, optional, menu height. Default expands to fit contents.
    * offsetX
    * offsetY
      - Ints, optional, amount of space between menu and screen edge.
      - Positive values taken from top/left of screen, negative values
        from bottom/right of screen.
      - Defaults will center the menu.
    * onCloseElement
      - Cue, optional, signalled when the menu is closed.
    * onRowChanged
      - Cue, optional, signalled when the player highlights a different
        row, either by clicking or using arrow keys.
      - This is the row that is highlighted.
      - Fires when the menu is first opened and a default row selected.
    * onColChanged
      - Cue, optional, signalled when the player highlights a different
        column, either by clicking or using arrow keys.
      - This will fire if the row changes and there is an interactive
        widget on the new row.
      - Does not fire when selecting a row with no interactive widgets.
    * onSelectElement
      - Cue, optional, signalled when the player selects a different element.
      - In practice, this appears to only work well for row selection.
      - An element is selected when:
        - It is clicked after already being highlighted.
        - 'Enter' is pressed with it highlighted.
      - Example use: the default options menu uses this to know when the
        player wants to open a submenu, eg. by 'selecting' Load Game.
    * frame
      - Subtable, properties for the frame, as follows:
      * backgroundID = "solid"
        - String, name of an icon to use as the background texture.
        - Set to a blank string to disable the background.
        - Solid by default, though encyclopedia system pictures can
          make for pretty backgrounds.
      * backgroundColor = 'Helper.color.semitransparent'
        - Color of the background texture.
        - Use 'Helper.color.white' when displaying pictures to retain
          their original coloring.
      * overlayID = ""
        - String, name of an icon to use as an overlay effect.
        - As of x4 2.6, this is bugged to use backgroundColor.
      * overlayColor = 'Helper.color.white'
        - Intended color of the overlay texture.
        - No effect currently.
      * standardButtons = 'Helper.standardButtons_CloseBack'
        - StandardButtonProperty
        - Which standard buttons will be included, eg. back/minimize/close.
        - These are generally placed in the top right.
      * standardButtonX = 0
        - Int, x offset for the buttons.
      * standardButtonY = 0
        - Int, y offset for the buttons.
      * showBrackets = false
        - Bool, if frame brackets will be shown.
      * closeOnUnhandledClick = false
        - Bool, if the menu triggers an onHide event if the player clicks
          outside of its area.
        - Pending development.
      * playerControls = false
        - Bool, if player controls are enabled while the menu is open.
        - Can use this to create an info menu in the corner while the
          player continues flying.
      * enableDefaultInteractions = true
        - Bool, if default inputs are enabled (escape, delete, etc.).
        - When false, these inputs have their normal non-menu effect,
          eg. escape will open the main options menu (which closes
          this menu automatically).
    * table
      - Subtable, properties for the table of widgets, as follows:
      * borderEnabled = true
        - Bool, if the table cells have a background color.
        - When set false, the mouse can no longer change row selection,
          only arrow keys can.
      * reserveScrollBar = true
        - Bool, if the table width reserves space for a scrollbar by
          adjusting column sizes.
      * wraparound = true
        - Bool, if arrow key traversal of table cells will wrap around edges.
      * highlightMode = "on"
        - String, controls highlighting behavior of table selections.
        - One of ["on","column","off","grey"]
          - "on"     : highlight row with blue box
          - "column" : highlight cell with blue box
          - "grey"   : highlight row with grey box
          - "off"    : no highlights of selected cell
      * multiSelect = false
        - Bool, whether the table allows selection of multiple cells.
      * backgroundID = ""
        - String, name of an icon to use as the background texture.
        - Works similar to that for frame, except doesn't cover the
          title bar.
      * backgroundColor = 'Helper.color.white'
        - Color of the background texture.
          
    onCloseElement event returns:
    * echo, event, id
    * reason 
      - String, reason for the closure.
      - "back" if the player pressed the back button, or pressed 'escape'
        with enableDefaultInteractions == true.
      - "close" if the player pressed the close button, pressed 'delete'
        with enableDefaultInteractions == true, or opened a different menu.
      - "minimize" if the player pressed the minimize button.
    
    onRowChanged event returns:
    * echo, event, id
    * row
      - Int, index of the newly highlighted row.
    * row_id
      - ID of the selected row, if available.
    * row_echo
      - Echo field of the row, if available.
    
    onColChanged event returns:
    * echo, event, id
    * row, col
      - Ints, row/col highlighted, generally corresponding to a widget.
    * widget_id
      - ID of the any selected widget at the give row/col, if available.
    * widget_echo
      - Echo field of the widget, if available.
    
    onSelectElement event returns:
    * echo, event, id
    * row
      - Int, index of the selected row.
    * row_id
      - ID of the selected row, if available.
    * row_echo
      - Echo field of the row, if available.
      
    -->
  <cue name="Create_Menu" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Init_Args_Table"/>
      <set_value name="$args.$command" exact="'Create_Menu'" />
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  
  <!--
    Close any currently displayed menu.
    -->
  <cue name="Close_Menu" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Init_Args_Table"/>
      <set_value name="$args.$command" exact="'Close_Menu'" />
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>

  <!--TODO: copy over some documentation from Make_Menu.-->
  <!--TODO: a way to dynamically condition when a menu is displayed, eg. only when debugging.-->
  <!--@doc-cue
    Register an options menu, which will be accessible as a submenu of
    the normal game options. These menus will be set to use the same
    visual style as the standard options menus, and so support a
    reduced set of args compared to standalone menus.
    
    Param: Table with the following items:
    * id
      - String, required unique identifier for this menu.
      - Needs to differ from egosoft menu names, as well as any other
        mod registered menus.
    * echo
      - Standard api args
    * title
      - Text to display in the table header.
    * columns
      - Integer, total number of columns in the menu table.
    * private
      - Int 0 or 1, optional, controls if the menu will be listed automatically
        in the general list of Extension Options menus.
      - Defaults to 0, non-private.
      - Set to private for submenus you will manually link to using
        Add_Submenu_Link.
    * onOpen
      - Cue to be called when the submenu is being opened by the player.
      - This cue should use addRow and Make_ functions to build the menu.
      - Do not call Create_Menu from this cue.
      - Widgets should be set up in the same frame; menu will display
        on the following frame.
      - The event.param will hold a table including $id, $echo, $columns.
    * onRowChanged
      - Same as for Create_Menu.
    * onColChanged
      - Same as for Create_Menu.
    * onSelectElement
      - Same as for Create_Menu.
    * table
      - Same as for Create_Menu.
      
      
    Call this each time the Reloaded cue is signalled. Example:
    ```xml
      <cue name="Register_Options_Menu" instantiate="true" namespace="this">
        <conditions>
          <event_cue_signalled cue="md.Simple_Menu_API.Reloaded"/>
        </conditions>
        <actions>
          <signal_cue_instantly
            cue="md.Simple_Menu_API.Register_Options_Menu"
            param = "table[
              $id      = 'my_unique_menu_1',
              $title   = 'My Menu',
              $onOpen  = Fill_Options_Menu,
              $columns = 2, 
              ]"/>
        </actions>
      </cue>
    ```
    -->
  <cue name="Register_Options_Menu" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Init_Args_Table"/>
      <set_value name="$args.$command" exact="'Register_Options_Menu'" />
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>

  <!--
    Display an options menu. Call this after all other widget creation
    cues.
    This is not for use with Standalone menus.
    
    -Removed; lua side does an automatic 1-frame delayed display() call.
    
  <cue name="Display_Menu" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Init_Args_Table"/>
      <set_value name="$args.$command" exact="'Display_Menu'" />
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
    -->
  
  <!--@doc-cue
    Add a link to another options menu.
    The other option menu will need to registered by Register_Options_Menu
    (normally with the private flag set).
    This will add a new row to the menu table, though that row will be
    ignored for the Make_ commands.
    Only for use with options menus, not those made through Create_Menu.
    
    Param:
      Table with the following items:
      * text
        - String, text to display in the selection line.
      * id
        - String, unique id of the submenu to be opened, as set at
          registration.
    -->
  <cue name="Add_Submenu_Link" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Init_Args_Table"/>
      <set_value name="$args.$command" exact="'Add_Submenu_Link'" />
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>

  <!--@doc-cue
    Refresh the current options menu by clearing its contents and
    calling the onOpen callback cue.  Does not change the depth of
    the options menu (eg. the back button is unaltered).
    
    For options menus only; standalone menus can refresh using
    a new call to Create_Menu.
    -->
  <cue name="Refresh_Menu" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Init_Args_Table"/>
      <set_value name="$args.$command" exact="'Refresh_Menu'" />
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>

  <!-- ################################################################### -->
  <!--                           Table stuff                               -->
  <!-- ################################################################### -->

  <!--@doc-section
    #### Table Cues
    -->

  <!--TODO: make rows selectable or not, set up echo and callbacks for
      RowSelected and similar events.-->
  <!--@doc-cue
    Add a row to the current menu.
    Following widget creation commands add to the most recently added row.
    Max is 160 rows (as of x4 4.0).
    
    Param: Table with the following items.
    * id, echo
      - Standard api args
    * selectable = true
      - Bool, if the row is selectable by the player.
      - Should always be true for rows with interactable widgets.
    * scaling = true
      - Bool, default ui scaling of cells (width/height/coordinates).
      - For now, this is expected to be overridden by per-widget settings.
    * fixed = false
      - Bool, fixes the row in place so it cannot be scrolled.
      - Requires prior rows also be fixed.
    * borderBelow = true
      - Shows a border gap before the next row, if present.
    * bgColor = 'Helper.color.transparent'
      - Color, default background of the row's cells.
    * multiSelected = false
      - Bool, row is preselected for multiselect menu tables.
  },
    -->
  <cue name="Add_Row" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Init_Args_Table"/>
      <set_value name="$args.$command" exact="'Add_Row'" />
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>

  <!-- TODO: maybe nice wrapper cues around this for each method. -->
  <!--@doc-cue
    Adjust some aspect of the table calling a backend table method.
    Generally for adjusting column widths.
    
    Param: Table with the following items.
    * method
      - String, name of the method being called.
      - Further args depend on the method, as follows:
    * ...
      - Further args depending on the method called.
      - Args described below.
      
    The possible methods are:
    - "setColWidth"
      * col
      - Int, column index to adjust. Indexing starts at 1.
      * width
        - Int, pixel width of column
      * scaling = true
        - Bool, if the width is ui scaled.          
    - "setColWidthMin"
      * col
      * width
        - Int, minimum pixel width of column
      * weight = 1
        - Int, how heavily this column is favored vs others when widths
          are calculated.
      * scaling = true
        - Bool, if the width is ui scaled.            
    - "setColWidthPercent"
      * col
      * width
        - Int, percent width of column of total table.          
    - "setColWidthMinPercent"
      * col
      * width
        - Int, percent width of column of total table.
      * weight = 1
        - Int, how heavily this column is favored vs others.          
    - "setDefaultColSpan"
      * col
      * colspan
        - Int, how many extra columns widgets created in this column
          will be stretched across.          
    - "setDefaultBackgroundColSpan"
      * col
      * bgcolspan
        - Int, how many extra columns the backgrounds of widgets created in
          this column will be stretched across.      
    -->
  <cue name="Call_Table_Method" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <include_actions ref="Init_Args_Table"/>
      <set_value name="$args.$command" exact="'Call_Table_Method'" />
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>

  <!-- ################################################################### -->
  <!--                             Widgets                                 -->
  <!-- ################################################################### -->
  
  <!--@doc-section
    #### Widget Creation Cues
    -->
  
  
  <!--TODO: rendertarget (placeholder sizing widget)-->
  
  <!--@doc-cue
    Make a "text" cell for displaying non-interactive text.
    Adds to the most recent row.
    
    Param: Table with the following items
    * col, colspan, id, echo
      - Standard api args
    * scaling, width, height, x, y, mouseOverText
      - Standard widget properties
    * cellBGColor, uiTriggerID
      - Standard cell properties    
    * text
      - String, text to display.
      - Updateable
    * halign
    * color
      - Updateable
    * titleColor
      - If given, puts the widget in title mode, which includes an
        automatic cell underline.
    * font
    * fontsize
    * wordwrap
    * minRowHeight
    
    
    Hint: egosoft menus make vertical space using wide, empty text cells.
    Example, assuming 2 table columns:
    ```xml      
      <signal_cue_instantly cue="md.Simple_Menu_API.Add_Row"
                            param ="table[$selectable = false]"/>
      <signal_cue_instantly
        cue="md.Simple_Menu_API.Make_Text"
        param = "table[
          $col = 1, 
          $colSpan = 2,
          $height = 'Helper.borderSize',
          $fontsize = 1,
          $cellBGColor = 'Helper.color.transparent60',
          ]"/>
    ```
    -->
  <cue name="Make_Text" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <set_value name="$args.$type" exact="'text'"/>
      <set_value name="$args.$command" exact="'Make_Widget'"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>


  <!--@doc-cue
    Make a "boxtext" cell.  Similar to text, but with an outlining box.
    Note: the outline box highlighting can behave oddly as the player
    interacts with other widgets.
    Adds to the most recent row.
        
    Param: Table with the following items
    * col, colspan, id, echo
      - Standard api args
    * scaling, width, height, x, y, mouseOverText
      - Standard widget properties
    * cellBGColor, uiTriggerID
      - Standard cell properties    
    * text
      - String, text to display.
      - Updateable
    * halign
    * color
      - Updateable
    * boxColor
      - Color of the surrounding box.
      - Updateable
    * font
    * fontsize
    * wordwrap
    * minRowHeight
    -->
  <cue name="Make_BoxText" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <set_value name="$args.$type" exact="'boxtext'"/>
      <set_value name="$args.$command" exact="'Make_Widget'"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  
  
  <!--@doc-cue
    Make a "button" cell.
    Adds to the most recent row.
    
    Param: Table with the following items.
    * col, colspan, id, echo
      - Standard api args
    * scaling, width, height, x, y, mouseOverText
      - Standard widget properties
    * cellBGColor, uiTriggerID
      - Standard cell properties   
    * onClick
      - Cue to callback when the button is left clicked.
    * onRightClick
      - Cue to callback when the button is right clicked.
    * text
      - TextProperty.
      - Updateable text and color
    * text2
      - TextProperty.
      - Updateable text and color
    * active = true
      - Bool, if the button is active.
      - Updateable
    * bgColor = 'Helper.defaultButtonBackgroundColor'
      - Color of background.
      - Updateable
    * highlightColor = 'Helper.defaultButtonHighlightColor'
      - Color when highlighted.
      - Updateable
    * icon
      - IconProperty
    * icon2
      - IconProperty
    * hotkey
      - HotkeyProperty
      
      
    onClick event returns:
    * row, col, echo, event, id
      
    onRightClick event returns:
    * row, col, echo, event, id
    -->
  <cue name="Make_Button" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <set_value name="$args.$type" exact="'button'"/>
      <set_value name="$args.$command" exact="'Make_Widget'"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  
  <!--@doc-cue
    Make an "editbox" cell, for text entry.
    Adds to the most recent row.
    
    Warning: due to a (likely) typo bug, x4 is limited to 5 text edit boxes
    in a single menu.
    If many edit fields are needed, consider using sliders for numeric values
    (limit 50), where users can click the slider displayed value to use it
    like an editbox.
    
    Param: Table with the following items
    * col, colspan, id, echo
      - Standard api args
    * scaling, width, height, x, y, mouseOverText
      - Standard widget properties
    * cellBGColor, uiTriggerID
      - Standard cell properties
    * onTextChanged
      - Cue to call when the player changes the box text. 
      - Occurs on every letter change.
    * onEditBoxDeactivated
      - Cue to call when the player deselects the box.
      - Deselection may occur when selecting another element, pressing enter,
        or pressing escape.
      - Does not trigger if the menu is closed.
    * bgColor = 'Helper.defaultEditBoxBackgroundColor'
      - Color of background.
    * closeMenuOnBack = false
      - Bool, if the menu is closed when the 'back' button is pressed while
        the editbox is active.
      - Description unclear.
    * defaultText
      - String, the default text to display when nothing present.
      - Updateable
    * textHidden = false
      - Bool, if the text is invisible.
    * encrypted = false
      - Bool, if the input has an encrypted style of display.
    * text
      - TextProperty
    * hotkey
      - HotkeyProperty
      
      
    onTextChanged event returns:
    * row, col, echo, event, id
    * text
      - String, the new text in the box.
        
    onEditBoxDeactivated event returns:
    * row, col, echo, event, id
    * text
      - String, the current text in the box.
    * textchanged
      - Bool, if the text was changed since being activated.
    * wasconfirmed
      - Bool, false if the player pressed "escape", else true.
    -->
  <cue name="Make_EditBox" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <set_value name="$args.$type" exact="'editbox'"/>
      <set_value name="$args.$command" exact="'Make_Widget'"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  
  
  <!--@doc-cue
    Make a horizontal "slidercell" cell.
    Adds to the most recent row.
    
    Param: Table with the following items
    * col, colspan, id, echo
      - Standard api args
    * scaling, width, height, x, y, mouseOverText
      - Standard widget properties
    * cellBGColor, uiTriggerID
      - Standard cell properties
    * onSliderCellChanged
      - Cue to call when the slider value is changed.
      - When the player drags the slider around, this will be called
        repeatedly at intermediate points.
      - When the player types into the editbox, this will trigger on
        every typed character.
    * onSliderCellActivated
      - Cue to call when the player activates the slider.
    * onSliderCellConfirm
      - Cue to call when the player deactivates the slider.
      - Triggers less often than onSliderCellChanged.
      - Recommended to use this over other events.
    * bgColor = 'Helper.defaultSliderCellBackgroundColor'
      - Color of background.
    * valueColor = 'Helper.defaultSliderCellValueColor'
      - Color of value.
    * posValueColor = 'Helper.defaultSliderCellPositiveValueColor'
      - Color, positive value if fromCenter is true
    * negValueColor = 'Helper.defaultSliderCellNegativeValueColor'
      - Color, negative value if fromCenter is true
    * min = 0
      - Min value the bar is sized for
    * max = 0
      - Max value the bar is sized for
      - Updateable
    * exceedMaxValue = false
      - Bool, if the player can go over the max value.
      - Requires min >= 0.
    * minSelect = none
      - Optional, Min value the player may select.
      - Defaults to min
    * maxSelect
      - Max value the player may select.
      - Defaults to max
      - Updateable
      - Do not use maxSelect if exceedMaxValue is true
    * hideMaxValue = false
      - Bool, hides the max value.
    * start = 0
      - Initial value
    * value
      - The current value of the slider.
      - Not used during setup (which instead uses start), but can be used
        to update the slider after creation.
      - Updateable
    * step = 1
      - Step size between slider points
    * suffix = ""
      - String, suffix on the displayed current value.
    * rightToLeft = false
      - Bool, enables a right/left mirrored bar.
    * fromCenter = false
      - Bool, bar extends from a zero point in the center.
    * readOnly = false
      - Bool, disallows player changes.
    * useInfiniteValue = false
      - Bool, sets slider to show infinity when infiniteValue is reached.
    * infiniteValue = 0
      - Value at which to show infinity when useInfiniteValue is true.
    * useTimeFormat = false
      - Bool, sets the slider to use a time format.
    * text
      - TextProperty
    
    
    onSliderCellChanged event returns:
    * row, col, echo, event, id
    * value
      - Longfloat, current value of the slider.
      
    onSliderCellActivated event returns:
    * row, col, echo, event, id
      
    onRightClick event returns:
    * row, col, echo, event, id
    * posx, posy
      - Coordinates of the widget (likely not useful).
      
    onSliderCellConfirm event returns:
    * row, col, echo, event, id
    * value
      - Longfloat, current value of the slider.
    * valuechanged
      - Bool, true if the value changed since being activated.
      - If the player escapes out of the editbox, this will be false and
        the value will be the pre-edit value.
      
    -->
  <cue name="Make_Slider" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <set_value name="$args.$type" exact="'slidercell'"/>
      <set_value name="$args.$command" exact="'Make_Widget'"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  
  
  <!--@doc-cue
    Make a "dropdown" selection cell.
    Adds to the most recent row.
    Note: indices start at 1.
    
    Param: Table with the following items
    * col, colspan, id, echo
      - Standard api args
    * scaling, width, height, x, y, mouseOverText
      - Standard widget properties
    * cellBGColor, uiTriggerID
      - Standard cell properties
    * options
      - List of tables describing each option.
      - Each subtable has these fields:
        * text = ""
          - String, option text.
        * icon = ""
          - String, icon name.
        * displayremoveoption = false
          - Bool, if true the option will show an 'x' that the player can
            click to remove it from the dropdown list.
        * ...
          - Similar to "echo", other subtable fields will be included
            in the cue callback.
    * onDropDownActivated
      - Cue to call when the player activates the dropdown.
    * onDropDownConfirmed
      - Cue to call when the player selects an option.
    * onDropDownRemoved
      - Cue to call when the player removes an option.
    * startOption = ""
      - String or number, id of the initially selected option.
      - Updateable
    * active = true
     - Bool, if the widget is active.
    * bgColor = 'Helper.defaultButtonBackgroundColor'
     - Color of background.
    * highlightColor = 'Helper.defaultButtonHighlightColor'
     - Color when highlighted.
    * optionColor = 'Helper.color.black'
      - Color of the options.
    * optionWidth, optionHeight = 0
      - Dimensions of the options.
    * allowMouseOverInteraction = false
    * textOverride = ""
    * text2Override = ""
    * text
     - TextProperty
    * text2
     - TextProperty
    * icon
     - IconProperty
    * hotkey
     - HotkeyProperty
      
      
    onDropDownActivated event returns:
    * row, col, echo, event, id
        
    onDropDownConfirmed event returns:
    * row, col, echo, event, id
    * option_index
      - Number, index of the selected option.
    * option
      - Table, the original option specification subtable given to
        widget creation that matches the option_index.
      
    onDropDownRemoved event returns:
    * row, col, echo, event, id
    * option_index
      - Number, index of the selected option.
    * option
      - Table, the original option specification subtable given to
        widget creation that matches the player selection.
      
    -->
  <cue name="Make_Dropdown" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <set_value name="$args.$type" exact="'dropdown'"/>
      <set_value name="$args.$command" exact="'Make_Widget'"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>


  <!--@doc-cue
    Make an "icon" cell. Note: many icons are large, and may need explicit
    width/height to adjust the sizing.
    Adds to the most recent row.
        
    Param: Table with the following items
    * col, colspan, id, echo
      - Standard api args
    * scaling, width, height, x, y, mouseOverText
      - Standard widget properties
    * cellBGColor, uiTriggerID
      - Standard cell properties    
    * icon = ""
      - String, icon id
      - Updateable
    * color = 'Helper.standardColor'
      - Color
      - Updateable
    * text
      - TextProperty
      - Updateable text
    * text2
      - TextProperty
      - Updateable text
    -->
  <cue name="Make_Icon" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <set_value name="$args.$type" exact="'icon'"/>
      <set_value name="$args.$command" exact="'Make_Widget'"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>


  <!--@doc-cue
    Make a "checkbox" cell.
    Adds to the most recent row.
    
    Param: Table with the following items
    * col, colspan, id, echo
      - Standard api args
    * scaling, width, height, x, y, mouseOverText
      - Standard widget properties
    * cellBGColor, uiTriggerID
      - Standard cell properties
    * onClick
      - Cue to callback when the checkbox is clicked.
    * checked = false
      - Bool or int, if checked initially.
      - Updateable
    * bgColor = 'Helper.defaultCheckBoxBackgroundColor'
     - Color of background.
    * active = true
     - Bool, if the widget is active.
     
    onClick event returns:
    * row, col, echo, event, id
    * checked
      - Int, 0 or 1, checkbox status after click.
      
    -->
  <cue name="Make_CheckBox" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <set_value name="$args.$type" exact="'checkbox'"/>
      <set_value name="$args.$command" exact="'Make_Widget'"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>

  
  <!--@doc-cue
    Make a "statusbar" cell. This is a bar that have a baseline value,
    is filled based on current value, and coloring is based on if the
    current is greater or less than the baseline.
    Adds to the most recent row.
    
    Param: Table with the following items
    * col, colspan, id, echo
      - Standard api args
    * scaling, width, height, x, y, mouseOverText
      - Standard widget properties
    * cellBGColor, uiTriggerID
      - Standard cell properties
    * current = 0
      - Int, determines fill of the bar.
      - Updateable
    * start = 0
      - Int, baseline value of the bar. Coloring of bar depends on current
        compared to start.
      - Updateable
    * max = 0
      - Int, max value of the bar, used for graphic scaling.
      - Min value of the bar is always pinned at 0.
      - Updateable
    * valueColor = 'Helper.defaultStatusBarValueColor'
      - Color
    * posChangeColor = 'Helper.defaultStatusBarPosChangeColor'
      - Color
    * negChangeColor = 'Helper.defaultStatusBarNegChangeColor'
      - Color
    * markerColor = 'Helper.defaultStatusBarMarkerColor'
      - Color
    -->
  <cue name="Make_StatusBar" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <set_value name="$args.$type" exact="'statusbar'"/>
      <set_value name="$args.$command" exact="'Make_Widget'"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>


  <!-- In development.
    Make a "shieldhullbar" cell, similar to that used on the map.
    May be linked to an object for a dynamic bar, or use fixed 
    percentages for a static var.
    
    Param: Table with the following items
    * col, colspan, id, echo
      - Standard api args
    * scaling, width, height, x, y, mouseOverText
      - Standard widget properties
      - Note: "height" behaves oddly and has not been fully figured out.
    * cellBGColor, uiTriggerID
      - Standard cell properties
    * object = none
      - Optional, object to reference for dynamic shields and hull.
      - Updateable
    * shield = 0, hull = 0
      - Int, percentages 0 to 100, fixed shield or hull bar fullness when not
        giving a target.
      - Updateable
    -->
  <cue name="Make_ShieldHullBar" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param"/>
      <set_value name="$args.$type" exact="'shieldhullbar'"/>
      <set_value name="$args.$command" exact="'Make_Widget'"/>
      <signal_cue_instantly cue="Send_Command" param="$args"/>
    </actions>
  </cue>
  

  <!--@doc-cue
    Update a widget's state after creation.
    
    Param: Table with the following items
    * id
      - String, original id assigned to the widget at creation.
    * ...
      - Any args to be updated, matching the original widget creation args
        layout.
      - Which widget properties can be updated depends on the specific widget.
  -->
  <cue name="Update_Widget" instantiate="true" namespace="this">
    <conditions>
      <event_cue_signalled/>
    </conditions>
    <actions>
      <set_value name="$args" exact="event.param" />
      
      <!-- Look up the id in recorded widget properties. -->
      <!-- Skip if there is an id problem. -->
      <do_if value="$args.$id? and Globals.$widget_properties.{Globals.$current}.{'$'+ $args.$id}?">
        <set_value name="$args_table" exact="Globals.$widget_properties.{Globals.$current}.{'$'+ $args.$id}"/>
        
        <!-- Fill in the row/col for the lua to find this widget. -->
        <set_value name="$args.$row" exact="$args_table.$row" />
        <set_value name="$args.$col" exact="$args_table.$col" />
        
        <!-- Set command string. -->
        <set_value name="$args.$command" exact="'Update_Widget'" />
        
        <!-- Send it off. -->
      <signal_cue_instantly cue="Send_Command" param="$args"/>
      </do_if>
      
      <do_else>
        <debug_text text="'Found no widget with id: %s'.[$args.$id]"
                  chance="Globals.$DebugChance" filter="general"/>
      </do_else>

    </actions>
  </cue>
  
  
  <!-- ################################################################### -->
  <!--                             Callbacks                               -->
  <!-- ################################################################### -->
  
  
  <!--
    Listen for the lua response signals, sent on player interraction with
    widgets or the menu in general. Handle callbacks to user cues.
    
    The callback will echo the original widget args table, annotated with
    the data returned from lua. User code may use this feature to attach
    data to widgets at creation time, and use that echo'd data in
    callback handling.
        
    Note: all events will return a generic table with results, which is
    translated correctly from lua tables. For widget events, this table will
    always have $row and $col of the widget the player modified, along with
    any per-widget state information.  See other documentation on the
    expected returned fields for each event.
  -->
  <cue name="Capture_Lua_Response" instantiate="true" namespace="this">
    <conditions>
      <event_ui_triggered screen="'Simple_Menu'" control="'Event'" />
    </conditions>
    
    <actions>
      <!-- Grab the returned value. -->
      <set_value name="$response" exact="event.param3" />
      
      <debug_text text="'Response: %s'.[$response]" 
              chance="Globals.$DebugChance" filter="general"/>
      
      <!-- Handle menu events different than widgets. -->
      <do_if value="$response.$type == 'menu'">
        
        <!-- onOpen will just signal this api to advance to the next properties. -->
        <do_if value="$response.$event == 'onOpen'">
          <!-- Inc 'current' with rollover, to switch later events to next menu. -->
          <set_value name="Globals.$current" exact="if (Globals.$current == 1) then 2 else 1"/>
        </do_if>

        <do_else>
          <!-- Look up the callback cue. -->
          <!-- Use @, so if a cue isn't found this yields null. -->
          <set_value name="$cue" exact="@Globals.$menu_properties.{Globals.$current}.{'$' + $response.$event}" />

          <!-- Handle the callback, if found and still existing. -->
          <do_if value="$cue.exists">
            <debug_text text="'Calling %s'.[$cue]"
                  chance="Globals.$DebugChance" filter="general"/>
                    
            <!-- Add the $echo to the response, or null. -->
            <set_value name="$response.$echo" exact="@Globals.$menu_properties.{Globals.$current}.$echo" />
            <!-- Add the $id to the response, or null. -->
            <set_value name="$response.$id" exact="@Globals.$menu_properties.{Globals.$current}.$id" />
          
            <!-- onRowChanged and onSelectElement will look up any extra row info. -->
            <do_if value="($response.$event == 'onRowChanged') or ($response.$event == 'onSelectElement')">
              <!-- Add the row $echo to the response, or null. -->
              <set_value name="$response.$row_echo" exact="@Globals.$row_properties.{Globals.$current}.{$response.$row}.$echo" />
              <!-- Add the row $id to the response, or null. -->
              <set_value name="$response.$row_id" exact="@Globals.$row_properties.{Globals.$current}.{$response.$row}.$id" />              
            </do_if>
          
            <!-- onColChanged wants to look up widget info. -->
            <do_elseif value="$response.$event == 'onColChanged'">
              <!-- Add the widget $echo to the response, or null. -->
              <set_value name="$response.$widget_echo" exact="@Globals.$widget_properties.{Globals.$current}.{$response.$row}.{$response.$col}.$echo" />
              <!-- Add the widget $id to the response, or null. -->
              <set_value name="$response.$widget_echo" exact="@Globals.$widget_properties.{Globals.$current}.{$response.$row}.{$response.$col}.$id" />
            </do_elseif>
          
            <!-- Make the callback. -->
            <signal_cue_instantly cue="$cue" param="$response" />
          </do_if>
        
          <!-- Print warning if no callback valid, if one was given.-->
          <do_else>
            <do_if value="Globals.$menu_properties.{Globals.$current}.{'$' + $response.$event}?">
              <debug_text text="'Invalid callback for menu event: ' + $response.$event"
                    chance="Globals.$DebugChance" filter="general"/>
            </do_if>
          </do_else>
        </do_else>
        
      </do_if>
      
      
      <!-- Handle widget events. -->
      <do_else>
        <!-- Look up the callback cue for this row/col and event. -->
        <!-- Use @, so if a cue isn't found this yields null. -->
        <set_value name="$args_table" exact="Globals.$widget_properties.{Globals.$current}.{$response.$row}.{$response.$col}" />
        <set_value name="$cue" exact="@$args_table.{'$' + $response.$event}" />
      
        <!-- Handle the callback, if found and still existing. -->
        <do_if value="$cue.exists">
          <debug_text text="'Calling %s'.[$cue]" 
                chance="Globals.$DebugChance" filter="general"/>
              
          <!-- Add the $echo to the response, or null. -->
          <set_value name="$response.$echo" exact="@$args_table.$echo" />

          <!-- Add the $id to the response, or null. -->
          <set_value name="$response.$id" exact="@$args_table.$id" />
          
          <!-- If this was a dropdown menu, add the option subtable. -->
          <do_if value="$args_table.$type == 'dropdown'">
            <!-- The response has the index of the selected option. -->
            <set_value name="$response.$option" exact="$args_table.$options.{$response.$option_index}"/>
          </do_if>

          <!-- Make the callback. -->
          <signal_cue_instantly cue="$cue" param="$response"/>
        </do_if>
      
        <!-- Print warning if no callback valid, but one was given. -->
        <do_else>
          <do_if value="$args_table.{'$' + $response.$event}?">
            <debug_text text="'Invalid callback for row,col: (%s,%s)'.[$response.$row, $response.$col]"
                  chance="Globals.$DebugChance" filter="general"/>
          </do_if>
          <!--<do_else>
            <debug_text text="'No callback for row,col: (%s,%s) in %s'.[$response.$row, $response.$col, $args_table]"
                  chance="Globals.$DebugChance" filter="general"/>
          </do_else>-->
        </do_else>
      </do_else>
      
    </actions>        
  </cue>
  
    
  <!--
    Listen for the lua requests to build an option menu.
    This will have somewhat similar behavior to Create_Menu (doing a reset
    for the fields that capture the new table properties).
    Calls the user callback cue to trigger menu building.
  -->
  <cue name="Capture_Lua_Display_Custom_Menu" instantiate="true" namespace="this">
    <conditions>
      <event_ui_triggered screen="'Simple_Menu'" control="'Display_Custom_Menu'" />
    </conditions>
    
    <actions>
      <!-- Grab the menu id requested. -->
      <set_value name="$id" exact="event.param3" />
      
      <!--Look up the args for this menu id. Suppress if not found.-->
      <set_value name="$menu_properties" exact="@Globals.$options_submenu_specs.{'$'+$id}"/>

      <!-- Look up the callback cue for this submenu, using $ prefixed id. -->
      <!-- Use @, so if a menu or cue isn't found this yields null. -->
      <set_value name="$cue" exact="@$menu_properties.$onOpen" />
      
      <!-- Handle the callback, if found and still existing. -->
      <do_if value="$cue.exists">

        <!-- Inc 'next' with rollover, to point it at the menu data to overwrite. -->
        <set_value name="Globals.$next" exact="if (Globals.$next == 1) then 2 else 1"/>

        <!-- Setup fresh globals. -->
        <set_value name="Globals.$widget_properties.{Globals.$next}" exact="table[]" />
        <set_value name="Globals.$row_properties.{Globals.$next}" exact="[]" />
        <set_value name="Globals.$row.{Globals.$next}" exact="0" />
        <!-- Link menu_properties to the args registered. -->
        <set_value name="Globals.$menu_properties.{Globals.$next}" exact="$menu_properties"/>

        <!--Set up the signal param.-->
        <set_value name="$event_param" exact="table[
                   $id      = @$menu_properties.$id,
                   $echo    = @$menu_properties.$echo,
                   $columns = @$menu_properties.$columns,
                   ]"/>

        <debug_text text="'Calling %s'.[$cue]" 
              chance="Globals.$DebugChance" filter="general"/>
        <signal_cue_instantly cue="$cue" param="$event_param"/>     
      </do_if>
      
      <!-- Print warning if no callback valid. -->
      <do_else>
        <debug_text text="'Found no callback for menu id: %s'.[$id]" 
              chance="Globals.$DebugChance" filter="general"/>
      </do_else>
      
    </actions>
  </cue>
  
  
  
  <!-- ################################################################### -->
  <!--                             Extra Docs                              -->
  <!-- ################################################################### -->
  <!--Note: put these inside cues, due to doc gen parsing top level then cue level.-->

  <!--@doc-section
  #### Helper Consts

  In the egosoft backend, there is a "Helper" module which defines many
  constants used in the standard menus such as colors, fonts, etc.
  Arguments may optionally be given as a string matching a Helper const,
  eg. 'Helper.color.brightyellow'. A selected list of possibly useful
  helper consts follows.  
  
  * Font related
    - Helper.standardFontBold = "Zekton bold"
    - Helper.standardFontMono = "Zekton fixed"
    - Helper.standardFontBoldMono = "Zekton bold fixed"
    - Helper.standardFontOutlined = "Zekton outlined"
    - Helper.standardFontBoldOutlined = "Zekton bold outlined"
    - Helper.standardFont = "Zekton"
    - Helper.standardFontSize = 9
    - Helper.standardTextOffsetx = 5
    - Helper.standardTextOffsety = 0
    - Helper.standardTextHeight = 16
    - Helper.standardTextWidth = 0
    - Helper.titleFont = "Zekton bold"
    - Helper.titleFontSize = 12
    - Helper.titleOffsetX = 3
    - Helper.titleOffsetY = 2
    - Helper.titleHeight = 20
    - Helper.headerRow1Font = "Zekton bold"
    - Helper.headerRow1FontSize = 10
    - Helper.headerRow1Offsetx = 3
    - Helper.headerRow1Offsety = 2
    - Helper.headerRow1Height = 20
    - Helper.headerRow1Width = 0
  
  * Sizing
    - Helper.standardButtonWidth = 30
    - Helper.standardButtonHeight = 20
    - Helper.standardFlowchartNodeHeight = 30
    - Helper.standardFlowchartConnectorSize = 10
    - Helper.standardHotkeyIconSizex = 19
    - Helper.standardHotkeyIconSizey = 19
    - Helper.subHeaderHeight = 18
    - Helper.largeIconFontSize = 16
    - Helper.largeIconTextHeight = 32
    - Helper.configButtonBorderSize = 2
    - Helper.scrollbarWidth = 19
    - Helper.buttonMinHeight = 23
    - Helper.standardIndentStep = 15
    - Helper.borderSize = 3
    - Helper.slidercellMinHeight = 16
    - Helper.editboxMinHeight = 23
    - Helper.sidebarWidth = 40
    - Helper.frameBorder = 25
    
  * StandardButtonProperty
    - Helper.standardButtons_CloseBack
    - Helper.standardButtons_Close
  
  * Colors
    - Helper.color.black
    - Helper.color.slidervalue
    - Helper.color.green
    - Helper.color.playergreen
    - Helper.color.grey
    - Helper.color.lightgreen
    - Helper.color.lightgrey
    - Helper.color.orange
    - Helper.color.darkorange
    - Helper.color.red
    - Helper.color.semitransparent
    - Helper.color.transparent60
    - Helper.color.transparent
    - Helper.color.white
    - Helper.color.yellow
    - Helper.color.brightyellow
    - Helper.color.warning
    - Helper.color.done
    - Helper.color.available
    - Helper.color.darkgrey
    - Helper.color.mission
    - Helper.color.warningorange
    - Helper.color.blue
    - Helper.color.standardColor
    - Helper.color.statusRed
    - Helper.color.statusOrange
    - Helper.color.statusYellow
    - Helper.color.statusGreen
    - Helper.color.defaultHeaderBackgroundColor
    - Helper.color.defaultSimpleBackgroundColor
    - Helper.color.defaultTitleBackgroundColor
    - Helper.color.defaultArrowRowBackgroundColor
    - Helper.color.defaultUnselectableBackgroundColor
    - Helper.color.defaultUnselectableFontColor
    - Helper.color.defaultButtonBackgroundColor
    - Helper.color.defaultUnselectableButtonBackgroundColor
    - Helper.color.defaultButtonHighlightColor
    - Helper.color.defaultUnselectableButtonHighlightColor
    - Helper.color.defaultCheckBoxBackgroundColor
    - Helper.color.defaultEditBoxBackgroundColor
    - Helper.color.defaultSliderCellBackgroundColor
    - Helper.color.defaultSliderCellValueColor
    - Helper.color.defaultSliderCellPositiveValueColor
    - Helper.color.defaultSliderCellNegativeValueColor
    - Helper.color.defaultStatusBarValueColor
    - Helper.color.defaultStatusBarPosChangeColor
    - Helper.color.defaultStatusBarNegChangeColor
    - Helper.color.defaultStatusBarMarkerColor
    - Helper.color.defaultBoxTextBoxColor
    - Helper.color.defaultFlowchartOutlineColor
    - Helper.color.defaultFlowchartBackgroundColor
    - Helper.color.defaultFlowchartValueColor
    - Helper.color.defaultFlowchartSlider1Color
    - Helper.color.defaultFlowchartDiff1Color
    - Helper.color.defaultFlowchartSlider2Color
    - Helper.color.defaultFlowchartDiff2Color
    - Helper.color.defaultFlowchartConnector1Color
    - Helper.color.defaultFlowchartConnector2Color
    - Helper.color.defaultFlowchartConnector3Color
      
  -->
  <!--TODO: how to support Helper tables of Text cell args.-->

</cues>
  
</mdscript><?xml version="1.0" encoding="utf-8" ?>
<mdscript name="Simple_Menu_Options" 
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" >
  <!--TODO: merge this into Simple_Menu_API? Or split off entirely?-->

  <!--
  MD side of a stock options menu for customizing menus.
  Initial effort will focus on egosoft menus, and not custom ones.
  
  This will handle the options submenu setup, and will store prior
  state to remember player's settings.
  
  TODO:
  Set up on/off widgets/buttons to be interactable by clicking anywhere on
  their  line, like ego menus. Currently they require clicking the widget itself.
  
  TODO:
  Option to force a value from md, and perhaps dynamically get a current value
  so the user doesn't have to save it themself if needing it for reference,
  and hence doesn't necessarily need to use a callback to capture it.
  (Perhaps give these as library include_actions.)
  
  TODO:
  Store values in the uidata instead of the save game (maybe optional per
  item), so they are preserved across new games.
  
  -->

  <cues>


    <!--
      Text storage cue, for easier lookup in general.
      Members are descriptive names of the text strings, prefixed with $.
    -->
    <cue name="Text"/>
    <library name="Load_Text">
      <actions>
        <set_value exact="{ 1001, 2658}" name="Text.$General" />
        <set_value exact="{ 1001, 2648}" name="Text.$on" />
        <set_value exact="{ 1001, 2649}" name="Text.$off" />
        <set_value exact="{68537, 1001}" name="Text.$General_Options" />
        <set_value exact="{68537, 1010}" name="Text.$Debug" />
        <set_value exact="{68537, 1011}" name="Text.$option_debug_enable" />
        <set_value exact="{68537, 1012}" name="Text.$option_debug_enable_mouseover" />
      </actions>
    </library>
    
    
    <!--
      Static cue for holding general state.
    
      * DebugChance
        - Int, 0 or 100.
      * storage
        - Table, keyed by option id, holding its current value.
        - Preserved across reloads.
      * options
        - Table of lists of subtables, outer key being option category,
          list holding options in registration order, final value being
          the actual option.
        - Option subtable contents described in Register_Option.
    -->
    <cue name="Globals">
      <actions>
        <!-- Create storage table on first load. -->
        <set_value name="Globals.$storage"   exact="table[]"/>
        <!-- Other setup handled below, triggered on menu api reload.-->
      </actions>
    </cue>

    <!-- 
      Handle menu reload, resetting globals and registering an options menu. 
      This will get special treatment by the menu api, and is
      appended to the general list of sub-menus from the main
      extension options menu.
      Eg. all of these loose options share the top level menu.
      
      Menu args may be largely ignored currently.
      TODO: $onSelectElement doesn't work when integrated into the
      stock menu (since bypassing the simple menu api setup); figure
      out how to get it working again.
      
      Note: cue name has a 2 due to legacy reasons, to work on prior saves.
    -->
    <cue name="Reset_On_Lua_Reload2" instantiate="true">
      <conditions>
        <event_cue_signalled cue="md.Simple_Menu_API.Reloaded"/>
      </conditions>
      <actions>
        <!--<debug_text text="'Reloading'" chance="100" filter="general"/>-->
        <set_value name="Globals.$DebugChance" exact="0"/>
        <set_value name="Globals.$options" exact="table[]" />

        <!--Load any text.-->
        <include_actions ref="Load_Text"/>

        <!--Load in any saved userdata.-->
        <include_actions ref="Load_Userdata"/>
        
        <signal_cue_instantly
          cue="md.Simple_Menu_API.Register_Options_Menu"
          param = "table[
            $id      = 'simple_menu_options',
            $columns = 2, 
            $title   = Text.$General_Options,
            $onOpen  = Build_Options_Menu,
            $onSelectElement = Handle_SelectElement,
            $private = 1,
            ]"/>

        <!-- Send a signal that all users listen to. -->
        <signal_cue_instantly cue="Reloaded"/>
      </actions>
    </cue>

    <!--Load in userdata, which is shared across saves.
      Values saves in userdata:
      - Globals.$storage
    -->
    <library name="Load_Userdata">
      <actions>
        <!--Set the default to init empty entries.-->
        <run_actions ref="md.Userdata.Read" result="$userdata">
          <param name="Owner" value="'sn_mod_support_apis'"/>
          <param name="Key" value="'simple_menu_options'"/>
          <param name="Default" value="table[
                       $storage = table[],
                       ]"/>
        </run_actions>
        <!--Extract fields.-->
        <set_value name="Globals.$storage" exact="$userdata.$storage"/>
      </actions>
    </library>

    <!--Trigger a lua update of userdata, setting it to save to uidata.xml.-->
    <library name="Update_Userdata">
      <actions>
        <run_actions ref="md.Userdata.Write">
          <param name="Owner" value="'sn_mod_support_apis'"/>
          <param name="Key" value="'simple_menu_options'"/>
          <param name="Value" value="table[
               $storage = Globals.$storage,
               ]"/>
        </run_actions>
      </actions>
    </library>

    <!--@doc-cue
    Dummy cue used for signalling that this api reloaded.
    Users that are registering options should listen to this
    cue being signalled.
    -->
    <cue name="Reloaded" instantiate="true">
      <conditions>
        <event_cue_signalled />
      </conditions>
      <actions>
      </actions>
    </cue>

    
    <!--@doc-cue
      User cue for registering a new option.
      Immediately on registration, the callback cue will be signalled
      with the currently stored setting (the default if this is a
      first-time registration, or what the player last selected).
      
      Input is a table with the following fields:
      * $id
        - String, unique identifier for this option.
      * $name
        - String, text to display on the menu widget label.
      * $category
        - Optional string, category name under which this option will be
          placed, along with any others of the same category.
        - If not given, or given as "General" will be set to General.
      * $mouseover
        - Optional string, text to display on menu widget mouseover.
      * $type
        - String, name of the type of widget to create.
        - "button": an on/off button.
        - "slidercell": a standard slider.
      * $default
        - Initial value of this option, if this $id hasn't been seen before.
        - "button" supports 0 or 1.
        - "slidercell" should have a value in the slider's range.
      * $args
        - Optional, Table of extra arguments to pass to the widget builder.
        - Supported fields match those listed in the simple menu api for
          the matching widget type.
        - Intended use is for setting slidercell limits.
      * $echo
        - Optional, anything (string, value, table, etc.), data to be
          attached to the callback cue param for convenience.
      * $callback
        - Cue to call when the player changes the option.
        - This is also called once during setup, after the existing md stored
          value is applied to the option.
        - Event.param will be a table of [$id, $echo, $value], where the
          value depends on the widget type.
        - "button" returns 0 (off) or 1 (on).
        - "slidercell" returns the slider value.
      * $skip_initial_callback
        - Optional, 0 or 1; if the initial callback during setup is skipped.
        - Defaults 0.
      * $disabled = 0
        - Optional, 0 or 1; if the option will not be displayed in the menu.
    -->
    <!--
    TODO:
      * $userdata
        - Optional bool, if true then the player value will be saved
          as userdata to uidata.xml, and restored across different saves
          or new games.
        - If false or not given, values are only saved to the current savegame.
    -->
    <cue name="Register_Option" instantiate="true" namespace="this">
      <conditions>
        <event_cue_signalled />
      </conditions>
      <actions>
        <set_value name="$option" exact="event.param.clone" />

        
        <!--TODO: variety of goodness checks on input args.-->
        <do_if value="$option.$id? and $option.$name? and $option.$type? and $option.$default?">          
          
          <!--Defaults.-->
          <do_if value="not $option.$echo?">
            <set_value name="$option.$echo" exact="null" />
          </do_if>
          <do_if value="not $option.$mouseover?">
            <set_value name="$option.$mouseover" exact="''" />
          </do_if>
          

          <do_if value="not $option.$category?">
            <set_value name="$option.$category" exact="Text.$General" />
          </do_if>
          <!--If a user explicitly tried to add to General, rename it
              based on the text lookup. (May also rename the above,
              but that is harmless.) -->
          <do_if value="$option.$category == 'General'">
            <set_value name="$option.$category" exact="Text.$General" />
          </do_if>
          
          <!--Save original id, then prefix with $ for use as a key.-->
          <set_value name="$option.$orig_id" exact="$option.$id" />
          <set_value name="$option.$id" exact="'$' + $option.$id" />
          <!--Same for category.-->
          <set_value name="$option.$orig_category" exact="$option.$category" />
          <set_value name="$option.$category" exact="'$' + $option.$category" />
          
          <!--Record the option. Make a new list if needed.-->
          <do_if value="not Globals.$options.{$option.$category}?">
            <set_value name="Globals.$options.{$option.$category}" exact="[]" />
          </do_if>
          <append_to_list name="Globals.$options.{$option.$category}" exact="$option" />
          
          <!--Record the default if needed.-->
          <do_if value="not Globals.$storage.{$option.$id}?">
            <set_value name="Globals.$storage.{$option.$id}"
                       exact="$option.$default"/>
          </do_if>
          
          <!--Do an initial call with the default or current value.
              Skip this if disabled, or skipping initial callback.
          -->
          <do_if value="$option.$callback? and $option.$callback.exists 
                        and not @$option.$disabled 
                        and not @$option.$skip_initial_callback">
            <signal_cue_instantly
              cue="$option.$callback"
              param="table[
                  $id = $option.$orig_id,
                  $value = Globals.$storage.{$option.$id},
                  $echo  = $option.$echo,
                  ]"/>
          </do_if>
        </do_if>
        <do_else>
          <!--TODO: error message if no id given.-->
        </do_else>
      </actions>
    </cue>

    <!--@doc-cue
        User cue to write a new value for an option, overwriting what is
        stored in this lib. The callback cue will not be signalled.
        
      Input is a table with the following fields:
      * $id
        - String, unique identifier for this option.
      * $value
        - The new value to store.
    -->
    <cue name="Write_Option_Value" instantiate="true" namespace="this">
      <conditions>
        <event_cue_signalled />
      </conditions>
      <actions>
        <!--This could have been given a $ prefixed id already; try both styles.-->
        <set_value name="$id" exact="event.param.$id" />
        <do_if value="not Globals.$storage.{$id}?">
          <set_value name="$id" exact="'$' + event.param.$id" />
        </do_if>
        <!--Error if still not found.-->
        <do_if value="not Globals.$storage.{$id}?">
          <debug_text text="'id %s not found in registerd options'.[event.param.$id]"
                    chance="Globals.$DebugChance" filter="general"/>
        </do_if>
        <do_else>
          <debug_text text="'id %s updating to %s (type %s)'.[
                    event.param.$id, 
                    event.param.$value, 
                    typeof event.param.$value]"
                    chance="Globals.$DebugChance" filter="general"/>
          <set_value name="Globals.$storage.{$id}" exact="event.param.$value"/>
        </do_else>

        <!--Need to update userdata.-->
        <include_actions ref="Update_Userdata"/>
      </actions>
    </cue>

    <!--@doc-cue
        User cue to read a value stored for an option.
        Kept for legacy support; preferably use Read_Value for an instant result.
        
      Input is a table with the following fields:
      * $id
        - String, unique identifier for this option.
      * $callback
        - Cue that will be signalled with a table holding $id and $value.
    -->
    <cue name="Read_Option_Value" instantiate="true" namespace="this">
      <conditions>
        <event_cue_signalled />
      </conditions>
      <actions>
        <set_value name="$id" exact="'$' + event.param.$id" />
        <signal_cue_instantly cue="event.param.$callback" param="table[
                              $id = event.param.$id,
                              $value = Globals.$storage.{$id},
                              ]"/>
      </actions>
    </cue>

    <!--@doc-cue
      User library to read a value stored for an option.
      Call using run_actions, capture response into result.
      
      Params:
      * id
        - String, unique identifier for this option, without $ prefix.
    -->
    <library name="Read_Value" purpose="run_actions">
      <params>
        <param name="id"/>
      </params>
      <actions>
        <!--TODO: error checking.-->
        <return value="Globals.$storage.{'$' + $id}"/>
      </actions>
    </library>
    
    <!--
      Library to call when setting or updating the value of widget.
      Inputs:
        $args   - table of args, with following already filled:
          $id   - string, name of value stored in globals.
          $type - type of widget, eg. "button"
          ...   - Tables for complex properties already created, eg. text.
      Outputs:
        $args filled in, depending on widget.
    -->
    <library name="Fill_Widget_Value">
      <actions>
                
        <do_if value="$args.$type == 'button'">
          <!-- Buttons will be on/off labeled toggles. -->
          <set_value name="$args.$text.$text" exact="if (Globals.$storage.{$args.$id}) then Text.$on else Text.$off"/>          
        </do_if>

        <do_elseif value="$args.$type == 'slidercell'">          
          <set_value name="$args.$start" exact="Globals.$storage.{$args.$id}"/>
        </do_elseif>
        
      </actions>
    </library>


    <!-- Callback for building the options menu. -->
    <cue name="Build_Options_Menu" instantiate="true" namespace="this">
      <conditions>
        <event_cue_signalled/>
      </conditions>
      <actions>
        
        <!--Sort the categories, putting General first.-->
        <set_value name="$categories" exact="Globals.$options.keys.list"/>
        <sort_list list="$categories"/>
        <set_value name="$sorted_categories" exact="['$'+Text.$General]" />
        <do_for_each name="$value" in="$categories">
          <do_if value="$value == '$'+Text.$General">
            <continue/>
          </do_if>
          <append_to_list name="$sorted_categories" exact="$value"/>
        </do_for_each>
        
        
        <!--Loop over the categories.-->
        <do_for_each name="$category" in="$sorted_categories">
          
          <!--Skip if category not used, eg. General.-->
          <do_if value="not Globals.$options.{$category}?">
            <continue/>
          </do_if>

          <!--Make a header.-->
          <signal_cue_instantly cue="md.Simple_Menu_API.Add_Row"
                                param ="table[$selectable = false]"/>
          <signal_cue_instantly
            cue="md.Simple_Menu_API.Make_Text"
            param = "table[
                $col = 1, 
                $colSpan = 2,
                $text = Globals.$options.{$category}.{1}.$orig_category,
                $halign = 'center',                
                $font = 'Helper.standardFontBold',
                $titleColor = 'Helper.defaultSimpleBackgroundColor',  
                ]"/>
          
          <!-- Loop over the options list. -->
          <do_for_each name="$option" in="Globals.$options.{$category}">

            <!-- Don't list disabled options. -->
            <do_if value="@$option.$disabled">
              <continue/>
            </do_if>
          
            <!-- Prepare a row -->
            <signal_cue_instantly cue="md.Simple_Menu_API.Add_Row" param="table[$echo = $option]"/>
        
            <!-- Generic label -->
            <signal_cue_instantly
              cue="md.Simple_Menu_API.Make_Text"
              param = "table[
                $col = 1, 
                $text = $option.$name, 
                $mouseOverText = $option.$mouseover,
                ]"/>
        
            <!-- Set up widget args, based on type. -->
            <do_if value="$option.$type == 'button'">
              <set_value name="$args" exact="table[
                $command = 'Make_Widget',
                $type    = 'button',
                $id      = $option.$id,
                $text    = table[$halign='left'],
                $col     = 2,
                $echo    = $option,
                $mouseOverText = $option.$mouseover,
                $onClick = Handle_Var_Change,
                ]"/>
            </do_if>
            <do_elseif value="$option.$type == 'slidercell'">
              <set_value name="$args" exact="table[
                $command = 'Make_Widget',
                $type    = 'slidercell',
                $id      = $option.$id,
                $col     = 2,
                $echo    = $option,
                $mouseOverText = $option.$mouseover,
                $onSliderCellConfirm = Handle_Var_Change,
                ]"/>
            </do_elseif>
          
            <!-- Merge in any extra specified args. -->
            <do_if value="$option.$args?">
              <do_all exact="$option.$args.keys.list.count" counter="$i">
                <set_value name="$key" exact="$option.$args.keys.list.{$i}"/>
                <set_value name="$val" exact="$option.$args.{$key}"/>
                <set_value name="$args.{$key}" exact="$val"/>
              </do_all>
            </do_if>
          
            <!-- Set initial value. -->
            <include_actions ref="Fill_Widget_Value"/>
          
            <!-- Create the widget. -->
            <signal_cue_instantly cue="md.Simple_Menu_API.Send_Command" param = "$args"/>
        
          </do_for_each>
        </do_for_each>
      </actions>
    </cue>

    <!--
    Handle element selection, mainly aimed at button rows.
    -->
    <cue name="Handle_SelectElement" instantiate="true">
      <conditions>
        <event_cue_signalled />
      </conditions>
      <actions>
        <!-- Ignore if no option (eg. some placeholder row or similar). -->
        <do_if value="event.param.$row_echo?">
          <set_value name="$option" exact="event.param.$row_echo"/>
          <!-- Rename the echo to match normal widgets. -->
          <set_value name="event.param.$echo" exact="event.param.$row_echo"/>
          <!-- If this was a button, pass off to Handle_Var_Change. -->
          <do_if value="$option.$type == 'button'">
            <signal_cue_instantly cue="Handle_Var_Change" param="event.param"/>
          </do_if>
        </do_if>
      </actions>      
    </cue>
    
    
    <!--
    Handle changes to global vars from menu.
    -->
    <cue name="Handle_Var_Change" instantiate="true">
      <conditions>
        <event_cue_signalled />
      </conditions>
      <actions>
        <!--<debug_text text="'Response: %s'.[event.param]" 
                chance="100" filter="general"/>-->
        
        <set_value name="$id" exact="event.param.$echo.$id"/>
        <!--<debug_text text="'Handling: %s'.[$id]"
                chance="100" filter="general"/>-->
        
        <!-- Generic on/off button handler. -->
        <do_if value="event.param.$echo.$type == 'button'">
          
          <!-- Toggle current option. -->
          <set_value name="Globals.$storage.{$id}" exact="if (Globals.$storage.{$id} == 0) then 1 else 0"/>

          <!-- Update the button. -->
          <set_value name="$args" exact="table[
              $id      = $id,
              $type    = 'button',
              $text    = table[],
              ]"/>
          <include_actions ref="Fill_Widget_Value"/>
          <signal_cue_instantly cue="md.Simple_Menu_API.Update_Widget" param = "$args"/>
        </do_if>

        <!-- Handle slider changes. -->
        <do_if value="event.param.$echo.$type == 'slidercell'">
          <set_value name="Globals.$storage.{$id}" exact="event.param.$value"/>
        </do_if>

        <!--Need to update userdata.-->
        <include_actions ref="Update_Userdata"/>
        
        <!--Return the value and original option id.-->
        <do_if value="event.param.$echo.$callback? and event.param.$echo.$callback.exists">
          <signal_cue_instantly 
            cue="event.param.$echo.$callback" 
            param="table[
                $id = event.param.$echo.$orig_id,
                $value = Globals.$storage.{$id},
                $echo  = event.param.$echo.$echo,
                ]"/>
        </do_if>
      </actions>
    </cue>

    
    <!-- Set up a menu option to turn on/off the debug logging. -->
    <cue name="Set_Menu_Options" instantiate="true">
      <conditions>
        <event_cue_signalled cue="md.Simple_Menu_Options.Reloaded"/>
      </conditions>
      <actions>
        <!--TODO: maybe hide this unless in developer mode (how to know?)-->
        <signal_cue_instantly
          cue="md.Simple_Menu_Options.Register_Option"
          param = "table[
            $category   = Text.$Debug,
            $id         = 'debug_menu_api',
            $name       = Text.$option_debug_enable,
            $mouseover  = Text.$option_debug_enable_mouseover,
            $default    = 0,
            $type       = 'button',
            $callback   = On_Option_Change,
            ]"/>

      </actions>
    </cue>

    <cue name="On_Option_Change" instantiate="true">
      <conditions>
        <event_cue_signalled />
      </conditions>
      <actions>
        <set_value name="$id"    exact="event.param.$id"/>
        <set_value name="$value" exact="event.param.$value"/>
        
        <do_if value="$id == 'debug_menu_api'">
          <!-- Change the debug chance in the main md file. -->
          <set_value name="md.Simple_Menu_API.Globals.$DebugChance"
                     exact ="if ($value) then 100 else 0"/>
        </do_if>

      </actions>
    </cue>

  </cues>

</mdscript><?xml version="1.0" encoding="utf-8" ?>
<mdscript name="Time_API" 
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" >

<!--
  MD side of the time api.
  This will mostly act as a wrapper on the lua functions, which have
  access to the real time (as opposed to game time).
-->
<cues>
  <!-- Register the main lua file. -->
  <cue name="Load_Lua_Files" instantiate="true">
    <conditions>
      <event_ui_triggered screen="'Lua_Loader'" control="'Ready'" />
    </conditions>
    <actions>
      <raise_lua_event name="'Lua_Loader.Load'"
                       param="'extensions.sn_mod_support_apis.lua_time_interface'"/>
      <raise_lua_event name="'Lua_Loader.Load'"
                       param="'extensions.sn_mod_support_apis.lua_time_pipe_time'"/>
    </actions>
  </cue>
  
  <!-- Register the python server. -->
  <cue name="Register_Pipe_Server" instantiate="true">
    <conditions>
      <event_cue_signalled cue="md.Pipe_Server_Host.Reloaded" />
    </conditions>
    <actions>
      <signal_cue_instantly
        cue="md.Pipe_Server_Host.Register_Module"
        param="'extensions/sn_mod_support_apis/python_time_api.txt'"/>
    </actions>
  </cue>
  
  <!-- 
  MD to lua heartbeat, firing every unpaused frame. 
  
  The primary motivation for this is that the lua side Update events
  sometimes go many frames/seconds without firing, though normally seem
  to fire regularly.  The reason for these hiccups is not understood,
  but an md-trigger signal to lua can provide a way to reliably fire
  every frame that the game is unpaused, alleviating the problem somwhat.
  -->
  <cue name="MD_New_Frame" instantiate="true" checkinterval="1ms">
    <!--No conditions.-->
    <actions>
      <raise_lua_event name="'Time.MD_New_Frame'"/>
    </actions>
  </cue>


  <!--
  The lua side will watch for onUpdate script calls as well as md
  heartbeat signals, and use these to generate a unified heartbeat,
  firing only once per frame at most (duplicate events suppressed).
  
  Users can listen to this cue being signalled in MD to trigger their
  cues every frame.
  
  The param will be the current engine time.
  <cue name="Frame_Advanced" instantiate="true" checkinterval="1ms">
    <conditions>
      <event_ui_triggered screen="'Time'" control="'Frame_Advanced'" />
    </conditions>
    <actions>
      <raise_lua_event name="'Time.MD_Heartbeat'"/>
    </actions>
  </cue>
  -->
  
</cues>
  
</mdscript><?xml version="1.0" encoding="utf-8" ?>
<mdscript name="Userdata"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" >

  <!--@doc-title Userdata API -->
  
  <!--
  MD side of the userdata api.
  
  Userdata is stored in uidata.xml, and controlled by lua. To share the data
  cleanly (without signalling delays on every access), lua will put a copy
  of loaded userdata in a player blackboard var, $__MOD_USERDATA.
  
  Changes made to userdata here will trigger a signal to lua to update
  its copy, which ultimately gets saved back to uidata.xml.
  
  Note: X4 is somewhat aggressive in deleting userdata that it thinks
  is unused, which has occurred more than one during development of
  this api.
  
  As a safety, the copy of userdata in the player blackboard var will be
  left in place, to be stored in a savegame. The lua will fall back on
  the blackboard var if the uidata is empty. This isn't a perfect solution,
  but may recover in some situations.
  -->
  <cues>
    <!-- Register the main lua file, with priority before other lua. -->
    <cue name="Load_Lua_Files" instantiate="true">
      <conditions>
        <event_ui_triggered screen="'Lua_Loader'" control="'Priority_Ready'" />
      </conditions>
      <actions>
        <raise_lua_event name="'Lua_Loader.Load'"
                         param="'extensions.sn_mod_support_apis.lua_userdata_interface'"/>
      </actions>
    </cue>

    <cue name="Listen_For_Lua_Reload" instantiate="true">
      <conditions>
        <event_ui_triggered screen="'Userdata'" control="'Ready'" />
      </conditions>
      <actions>
        <!-- Send a signal that all users can listen to. -->
        <signal_cue_instantly cue="Reloaded"/>
      </actions>
    </cue>

    <!--@doc-cue
    Dummy cue used for signalling that the api reloaded.
    Users can listen to this being signalled to know it is safe to
    read userdata. This will be signalled before the other apis load,
    so waiting for this is unnecessary if already waiting for other apis.
    -->
    <cue name="Reloaded" instantiate="true">
      <conditions>
        <event_cue_signalled />
      </conditions>
      <actions>
      </actions>
    </cue>

    
    <!--@doc-cue
      Read a userdata value, using a paramaterized library call.
      Params:
      * Owner
        - String, unique name of the owner of this data (mod or modder).
        - Should avoid conflicting with other mods.
      * Key
        - String, optional, more specific name of the owner userdata when
          the owner entry is a table.
        - If not given, the full Owner entry is returned.
      * Default
        - Optional, default value to return if the Owner/Key lookup fails.
        - If not given, null is returned.
      
      Example:
        ```xml
        <run_actions ref="md.Userdata.Read" result="$retval">
          <param name="Owner" value="'sn_mod_support_apis'"/>
          <param name="Key" value="'hotkey_data'"/>
          <param name="Default" value="table[]"/>
        </run_actions>
        ```
    -->
    <library name="Read" purpose="run_actions">
      <params>
        <param name="Owner"/>
        <param name="Key" default="null"/>
        <param name="Default" default="null"/>
      </params>
      <actions>
        <!--Check for string Owner, string or null Key.-->
        <do_if value="(typeof $Owner == datatype.string )
               and (($Key == null) or (typeof $Key == datatype.string))">
          
          <!--Prefix string names with $ for table lookup.-->
          <set_value name="$Owner" exact="'$' + $Owner"/>
          <!--Temp target var to hold partial deref.-->
          <set_value name="$target" exact="player.entity.$__MOD_USERDATA"/>
        
          <!--Check if this Owner is missing.-->
          <do_if value="not $target.{$Owner}?">
            <return value="$Default"/>
          </do_if>
          <set_value name="$target" exact="$target.{$Owner}"/>
        
          <!--If no key given, return the full Owner data.-->
          <do_if value="$Key == null">
            <return value="$target"/>
          </do_if>
     
          <!--Prefix and check if the key is missing.-->
          <set_value name="$Key" exact="'$' + $Key"/>
          <do_if value="not $target.{$Key}?">
            <return value="$Default"/>
          </do_if>
          <!--Return the found key data.-->
          <return value="$target.{$Key}"/>          
        </do_if>
        
        <!--If here, an error occurred. TODO: message.-->
        <return value="$Default"/>
      </actions>
    </library>


    <!--@doc-cue
      Write a userdata value, using a paramaterized library call.
      Params:
      * Owner
        - String, unique name of the owner of this data (mod or modder).
        - Should avoid conflicting with other mods.
      * Key
        - String, optional, more specific name of the owner userdata when
          the owner entry is a table.
        - If not given, the full Owner entry is overwritten.
      * Value
        - Table or other basic data type to save.
        - Should generally consist of numbers, strings, nested lists/tables,
          and similar basic values that are consistent across save games.
        - Avoid including references to objects, cue instances, etc. which
          differ across save games.
        - If "null", the userdata entry will be removed.
      
      Example:
        ```xml
        <run_actions ref="md.Userdata.Write">
          <param name="Owner" value="'sn_mod_support_apis'"/>
          <param name="Key" value="'hotkey_data'"/>
          <param name="Value" value="table[$zoom='z']"/>
        </run_actions>
        ```
    -->
    <library name="Write" purpose="run_actions">
      <params>
        <param name="Owner"/>
        <param name="Key" default="null"/>
        <param name="Value"/>
      </params>
      <actions>
        <!--Check for string Owner, string or null Key.-->
        <do_if value="(typeof $Owner == datatype.string )
               and (($Key == null) or (typeof $Key == datatype.string))">
          
          <!--Prefix string names with $ for table lookup.-->
          <set_value name="$Owner_str" exact="'$' + $Owner"/>
          <!--Temp target var to hold partial deref.-->
          <set_value name="$target" exact="player.entity.$__MOD_USERDATA"/>

          <!--Handle owner-only cases.-->
          <do_if value="$Key == null">
            <!--Do a direct write or overwrite for this owner.-->
            <set_value name="$target.{$Owner_str}" exact="$Value"/>
          </do_if>

          <!--Handle key cases.-->
          <do_else>
            <!--Check if this Owner is missing.-->
            <do_if value="not $target.{$Owner_str}?">
              <!--Create a new table entry.-->
              <set_value name="$target.{$Owner_str}" exact="table[]"/>
            </do_if>
            <set_value name="$target" exact="$target.{$Owner_str}"/>
          
            <!--Write or overwrite the key.-->
            <set_value name="$target.{'$' + $Key}" exact="$Value"/>
          </do_else>
        
          <!--Signal the lua side to update this specific entry.-->
          <raise_lua_event name="'Userdata.Update'" param="$Owner"/>
          <raise_lua_event name="'Userdata.Update'" param="$Key"/>
        </do_if>
        <!--If here, an error occurred. TODO: message.-->
        
      </actions>
    </library>

  </cues>

</mdscript><?xml version="1.0" encoding="utf-8" ?>
<language>
<!--Default text, as an alternative to 0001-l044.xml -->
<!--Using phone-style code for "nukes"-->
<page id="68537" title="SirNukes texts" descr="0" voice="no">
  
  <!--Mod apis start at 1000-->
  <!--TODO: reconstruct some of these with refs to base language entries.-->
  <t id="1000">Erweiterungsoptionen</t>
  <t id="1001">Allgemeine Optionen</t>

  <t id="1010">Debug</t>
  <!--Simple menu options debug on/off button.-->
  <t id="1011">Aktiviere Menü-API Debug Log</t>
  <t id="1012">Gibt zusätzliche Statusinformationen im Debug Log aus. </t>

  <t id="1021">Aktiviere Hotkey für API Debug Logs</t>

  <t id="1030">Named Pipes API</t>
  <t id="1031">connected</t>
  <t id="1032">disconnected</t>
  <t id="1033">Pipe</t>
  <t id="1034">Status</t>
  <t id="1035">Name of the pipe</t>
  <t id="1036">If the pipe is connected</t>
  
  <t id="1040">Deaktiviere "Interact Menu API"</t>
  <t id="1041">Aktiviere "Interact API" Debug Logs</t>

</page>

</language>
<?xml version="1.0" encoding="utf-8" ?>
<language>
<!--Default text, as an alternative to 0001-l044.xml -->
<!--Using phone-style code for "nukes"-->
<page id="68537" title="SirNukes texts" descr="0" voice="no">

<!--Mod apis start at 1000-->
<!--TODO: reconstruct some of these with refs to base language entries.-->
<t id="1000">拡張オプション</t>
<t id="1001">一般項目</t>

<t id="1010">デバッグ</t>
<!--Simple menu options debug on/off button.-->
<t id="1011">メニューAPIのデバッグログを有効にする</t>
<t id="1012">一般的な追加のAPI状態をデバッグログに追記します。</t>

<t id="1021">ホットキーAPIのデバッグログを有効にする</t>

<t id="1030">名前付きパイプAPI</t>
<t id="1031">接続</t>
<t id="1032">切断</t>
<t id="1033">パイプ</t>
<t id="1034">ステータス</t>
<t id="1035">パイプの名前。</t>
<t id="1036">パイプが接続されているかどうか。</t>

<t id="1040">インタラクトメニューAPIを無効化する</t>
<t id="1041">インタラクトメニューAPIのデバッグログを有効にする</t>

</page>

</language>
<?xml version="1.0" encoding="utf-8" ?>
<language>
<!--Default text, as an alternative to 0001-l044.xml -->
<!--Using phone-style code for "nukes"-->
<page id="68537" title="SirNukes texts" descr="0" voice="no">
  
  <!--Mod apis start at 1000-->
  <!--TODO: reconstruct some of these with refs to base language entries.-->
  <t id="1000">Extension Options</t>
  <t id="1001">General Options</t>

  <t id="1010">Debug</t>
  <!--Simple menu options debug on/off button.-->
  <t id="1011">Enable menu api debug logs</t>
  <t id="1012">Prints extra api status info to the debug log, general category</t>
  
  <t id="1021">Enable hotkey api debug logs</t>

  <t id="1030">Named Pipes API</t>
  <t id="1031">connected</t>
  <t id="1032">disconnected</t>
  <t id="1033">Pipe</t>
  <t id="1034">Status</t>
  <t id="1035">Name of the pipe</t>
  <t id="1036">If the pipe is connected</t>

  <t id="1040">Disable interact menu api</t>
  <t id="1041">Enable interact api debug logs</t>
  
</page>

</language>
